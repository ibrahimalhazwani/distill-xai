<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">

    <head>
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" />

        <script src="https://distill.pub/template.v2.js"></script>
        <script src="https://cdnjs.com/libraries/mathjs"></script>
        <script src="https://unpkg.com/mathjs@10.6.3/lib/browser/math.js"></script>

        <script src="https://cdn.plot.ly/plotly-2.12.1.min.js"></script>
        <script src="plotly-2.12.1.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>

        <!-- Load CSS file. -->
        <link rel="stylesheet" href="style.css">
    </head>

<body distill-prerendered="">
    <distill-header distill-prerendered="">
        <div class="content">
            <a class="logo" href="/">
                <svg viewBox="-607 419 64 64">
                    <path
                        d="M-573.4,478.9c-8,0-14.6-6.4-14.6-14.5s14.6-25.9,14.6-40.8c0,14.9,14.6,32.8,14.6,40.8S-565.4,478.9-573.4,478.9z">
                    </path>
                </svg>
                Distil
            </a>
            <nav class="nav">
                <a href="/about/">About</a>
                <a href="/prize/">Prize</a>
                <a href="/journal/">Submit</a>
            </nav>
        </div>
    </distill-header>

    <d-title style="padding-bottom: 0">
        <h1>What is it next?</h1>
        <p>How recommender systems choose the next item.</p>
        <d-figure class="l-screen shade-figure" style="border-bottom: none">
        </d-figure>
    </d-title>

    <d-byline>
        <div class="byline grid">
            <div class="authors-affiliations grid">
                <h3>Authors</h3>
                <h3>Affiliations</h3>
                <p class="author">
                    Ibrahim Al-Hazwani
                </p>
                <p class="affiliation">
                    University of Zurich and UZH Digital Society Initiative
                </p>
                <p class="author">
                    Yves Rutishauser
                </p>
                <p class="affiliation">
                    University of Zurich
                </p>
                <p class="author">
                    Gabriela Morgenshtern

                </p>
                <p class="affiliation">
                    University of Zurich
                </p>
                <p class="author">
                    Menna El-Assady
                </p>
                <p class="affiliation">
                    ETH Zürich
                </p>
                <p class="author">
                    Jürgen Bernard
                </p>
                <p class="affiliation">
                    University of Zurich and UZH Digital Society Initiative
                </p>
            </div>
            <div>
                <h3>Published</h3>
                <p>TBA</p>
            </div>
            <div>
                <h3>DOI</h3>
                <p>TBA</p>
            </div>
        </div>
    </d-byline>

    <d-article>
        <div class="centered">
            <img src='rs-timeline.png' width="700px" height="187px">
        </div>
        <figcaption class="centered">
            Timeline of recommender systems. Highlighted are the two methods described in this article. A clear
            distinction between pre and post deep learning era is on the year 2012.
        </figcaption>
        <p></p>
        <p>
            If you have ever used an e-commerce service or a streaming platform, you have already seen at least
            one of these: <q><i>recommended for you</i></q>, or <q><i>other users have also bought this</i></q>. With
            this article, we will give you an introduction to Recommender Systems (RS), and illustrate how new
            deep-learning algorithmic techniques in this field work.
        <p>
            First, we use a toy example to illustrate how Matrix Factorization a relatively simply designed
            recommender system works. Then, we dive into two modern approaches: neural networks and deep learning
            models (via Guo et al's DeepFM). We visualize and discuss the distributions of the ratings data used to
            train these two models, focusing on how to use these visualizations to explain the differences in the
            models' competence in predicting a user's rating of a movies they've seen. Following this article, we hope
            that you will have some intuition and visual understanding of how RS work.

        <p>
            Recommender Systems can be defined as software tools and techniques that provide suggestions for items
            to interact with a given user [1]. Usually, and so especially on the web, recommendations are
            personalized to the specific user interacting with the system. By <q><i>item</i></q>, we refer to
            <i>what</i> the system is recommending to the user. This item could represent the next movie to watch, song
            to listen to, the fastest path to a destination, or the best match for a particular job position (or your
            next date!).
        <p style="color: red;">TO EDIT (unclear how this relates to above): It is important to note that
            non-personalized recommendations also exist, such as those you may have seen in print newspapers or
            magazines.</p>


        <!--
            <d-cite key="ricci2011introduction">
                <d-hover-box id="hover-box" style="display: none;">
                    <ul>
                        <li>
                            <strong>Introduction to recommender systems handbook</strong>
                            <a href="https://doi.org/10.1007/978-0-387-85820-3_1"></a>
                            <br> F. Ricci, L. Rokach, B. Shapira
                            <br> Recommender Systems Handbook. Springer, Boston, MA.
                            <a href="https://doi.org/10.1007/978-0-387-85820-3_1" style="text-decoration: inherit;">DOI: 10.1007/978-0-387-85820-3_1 </a>
                        </li>
                    </ul>
                </d-hover-box>
                <div id="citation-" class="citation">
                    <span class="citation-number">[1]</span>
                </div>
            </d-cite>
        -->
        </p>


        <h2>Recommender Systems: what are they?</h2>

        <!-- <img src='rs-workflow2.png' width="700px"> -->

        <p>
            In order to generate recommendations, RS require several types of input data. Examples of these may
            include users' preferences, items' characteristics, explicit feedback, implicit feedback, and essentially
            can be any measurable information about either the items or the users the RS is interested in modeling.
        </p>
        <div class="example">
            <p class="example_text">
                The recommendation process can be devided in four steps: querying, retrieving, filtering, scoring, and
                ranking.
            </p>
            <p class="example_text">
                <u>How to use it</u>: mouse over the different steps to know more about them.
            </p>
            <div class="row">
                <div class="column-rs">
                    <figcaption>
                        Query the database
                    </figcaption>
                </div>
                <div class="column-rs">
                    <figcaption>
                        Retrieval
                    </figcaption>
                </div>
                <div class="column-rs">
                    <figcaption>
                        Filtering
                    </figcaption>
                </div>
                <div class="column-rs">
                    <figcaption>
                        Scoring and ranking
                    </figcaption>
                </div>
            </div>
            <div class="row">
                <div class="column-rs">
                    <div id="parent">
                        <img src="avatar-rs-workflow.png" width="150px">
                        <div id="popup" style="display: None">
                            The recommendation process starts when a user makes a query to an online platflorm.
                        </div>
                    </div>
                </div>
                <div class="column-rs-cloud">
                    <div id="parent2">
                        <img src="retrieve-rs-workflow.png" width="150px">
                        <div id="popup2" style="display: None">
                            Based on the query the items are retrieval with no specific orde from the database.
                        </div>
                    </div>
                </div>
                <div class="column-rs">
                    <div id="parent3">
                        <img src="filter-rs-workflow.png" width="150px">
                        <div id="popup3" style="display: None">
                            The elements retrieved are then filtered based on specific features of the items or the
                            users.
                        </div>
                    </div>
                </div>
                <div class="column-rs">
                    <div id="parent4">
                        <img src="ranking-rs-workflow.png" width="150px">
                        <div id="popup4" style="display: None">
                            Finally, each item will be given a score and ranked based on it.
                        </div>
                    </div>
                </div>
            </div>
            <p></p>
        </div>
        <p></p>
        <p>
            The most accessible data are explicit ratings, which include explicit input from the user regarding
            their level of interest in a product i.e. rating that the user gives to an item. Usually, explicit
            feedback can be represented by a sparse matrix, since users are likely to rate only a small percentage of
            entirety of items a dataset includes. We can't expect a single user to have seen every possible movie! But
            we can learn about their similarity to other users, and thus try to predict how this user would feel <i>if
                they were to watch</i> a new movie.
        </p>
        <p>
            When explicit feedback is not available, it is possible to use implicit feedback that reflects user
            behavior. Examples of implicit feedback include the browser history on a website, the number of
            clicks made on a given page, or a user's pattern of mouse movement. As opposed to explicit feedback,
            implicit feedback can be represented by a densely filled matrix, perhaps because we have more say in how
            this data is to be collected or organized.
        </p>
        <p>
            Classical recommender systems can be grouped into two main approaches: content-based (CB) and
            collaborative filtering (CF).
            <!--The former one recommends an item, i.e. movie, song, ad, etc., to a user based on the item
            characteristics and user's interests. The latter one uses the known preferences of a group of users to make
            recommendations or predictions for other users.-->
        </p>

        <div>
            <div class="centered">
                <img src='CB.png' width="383px" height="470px">
            </div>
            <p>
                <b>Content-based filtering</b> The main idea of content-based filtering is to generate a
                recommendations using additional information about the given user and item, through what we
                call <i>features</i>, which explain the observed interaction between a user and an item.
                <!-- Content-based methods are less prone to the <i>Cold-Start Problem</i> because new items or new
                users can be described using characteristics relating to them alone, rather than by describing them
                through their similarity to the behaviour of others'. -->
            </p>
            <figcaption id="left_caption_CB">
                On the left is an illustration of the content-based process. If Alan has watched one movie, the
                recommender system will then find similar movies to it, and Alan will be given a recommendation from the
                set of movies most similar to the one he has already watched.
            </figcaption>
        </div>

        <div>
            <div class="centered">
                <img src='CF.png' width="383px" height="408px">
            </div>
            <p>
                <b>Collaborative filtering</b> The main idea of collaborative filtering is that past
                user-item interaction, like providing ratings to movies watched in the past, is sufficient to detect
                similar users and/or items, cluster them, and make new predictions based on the similarity existing
                within a cluster [6].
                <!-- The main issue with CF method is known as the <i>Cold-Start Problem</i>. -->

            </p>
            <figcaption id="left_caption_CF">
                On the left is an illustration of the collaborative filtering process. If Alan and Sarah have
                watched the same movies and have the same interests, the recommender system will learn this information
                and recommend to Sarah a movie that Alan has watched.
            </figcaption>
        </div>
        <p></p>

        <!-- User A will be
                recommended with a new item based on the interest of similar user B. Collaborative filtering methods
                belong to the bigger category of approaches called memory-based. that the predictions for a given user-item pair are made via dot
                product. So, if an item is not in the training dataset, the recommender system will not be able to query
                this item to generate a recommendation.  One of the most used
                methods, which is going to be decribed later, is called Matrix Factorization (MF).This issue is known as the cold-start problem. The main downside of this method is knwon as cold-start problem.-->

        <p></p>
        <p style="color: red;">
            WRITE SOMETHING HERE
        </p>
        <table>
            <tr>
                <th></th>
                <th>Content-based</th>
                <th>Collaborative Filtering</th>
            </tr>
            <tr>
                <th>Advantages</th>
                <td>
                    <ul>
                        <li>Does not need any data about the other users.</li>
                        <li>Can recommend niche items.</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Does not require domain knowledge.</li>
                        <li>Help users to discover new interests.</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <th>Disadvantages</th>
                <td>
                    <ul>
                        <li>Requires a lot of domain knowledge.</li>
                        <li>Makes recommendation only based on the existing interests of the user.</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Can not handle fresh items or user (cold-start problem).</li>
                        <li>Hard to include features beyond the query.</li>
                    </ul>
                </td>
            </tr>
        </table>
        <div>
            <h2>
                An interpretable collaborative filtering recommender system: Matrix Factorization
            </h2>
            <div class="example">
                <div class="row">
                    <div class="column">
                        <div id="parent5">
                            <img src="rating-matrix.png" width="300px">
                        </div>
                    </div>
                    <div class="column-umatrix">
                        <div id="parent6">
                            <img src="user-matrix.png" width="150px">
                            <div id="popup6" style="display: None">The <b>user matrix</b> stores the users' item feature
                                preference.
                                <!-- Usually the preference are in the range [0,1] where 0 means that the user
                                does not like that feature, while one means that the use like it. -->
                            </div>
                        </div>
                    </div>
                    <div class="column-imatrix">
                        <div id="parent7">
                            <img src="item-matrix.png" width="150px">
                            <div id="popup7" style="display: None">The <b>item matrix</b> stores the movies' features
                                scores.
                            </div>
                        </div>
                    </div>
                </div>
                <!-- <div class="row">
                    <div class="column-rs-rmatrix">
                        <p>Rating Matrix</p>
                    </div>
                    <div class="column-rs-umatrix">
                        <p>User Matrix</p>
                    </div>
                    <div class="column-rs-imatrix">
                        <p>Item Matrix</p>
                    </div>
                </div> -->
            </div>
            <p></p>

            <p>
                Matrix Factorization is a class of collaborative filtering techniques [3] it is used to
                generate latent features (<i>embeddings</i>) when two different entities are multiplied together. In
                its most simplistic form, Matrix Factorization characterizes both the items and the users by a vector of
                factors (<i>matrixes</i>). This kind of method has become popular, since it combines robust scalability
                with predictive accuracy, while offering flexibility for modeling real-life scenarios [2]. Moreover,
                since it is based on pure math it can be classified as an interpretable recommendation method.
            </p>
            <p>
                Each item <i>i</i> and user <i>u</i> are associated with a vector <i>q<sub>i</sub></i> and
                <i>w<sub>u</sub></i>, respectively. For a given item, the corresponding vector measures the degree
                to which a feature represents the item dataset. Similarly, the user vector <i>w<sub>u</sub></i>
                measures the degree of interest the user has in the item dataset.
            </p>
            <p>The interaction, defined as <q>the interest of the user <i>u</i> in item <i>i</i></q> , is then captured
                by the dot product of these two vectors. Once all the dot products are computed, it becomes possible to
                rank the predicted ratings and identify the best item to recommend to any given user.
            </p>

            <div class="row">
                <div class="column">
                </div>
                <div class="column">
                    <img src="mf-formula.png" height="200px">
                </div>
                <div class="column">
                </div>
            </div>
            <div class="centered">
                <figcaption>Matrix Factorization formula.</figcaption>
            </div>

            <!-- <span class="katex-display">
                <span class="katex">
                    <span class="katex-mathmk">
                        <math>
                            <semantics>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mi>qui</mi>
                                    </msub>
                                    <mo>=</mo>
                                    <msup>
                                        <msub>
                                            <mi>q</mi>
                                            <mi>i</mi>
                                        </msub>
                                        <mi>T</mi>
                                    </msup>
                                    <mo>&#8901</mo>
                                    <msub>
                                        <mi>w</mi>
                                        <mi>u</mi>
                                    </msub>
                                    <mo>
                                        =
                                    </mo>
                                    <msub>
                                        <mo>&#8721;</mo>
                                        <mi>k</mi>
                                    </msub>
                                    <msub>
                                        <mi>p</mi>
                                        <mi>ik</mi>
                                    </msub>
                                    <mo>&#8901</mo>
                                    <msub>
                                        <mi>w</mi>
                                        <mi>ku</mi>
                                    </msub>
                                </mrow>
                            </semantics>
                        </math>
                    </span>
                </span>
            </span> -->

            <div class="example">
                <p> </p>
                <p class="example_text">
                    Let's consider the following example: you are planning a movie night with your friends Anna,
                    Jonny, and Kimi. You know that Anna likes both horror movies and comedy, Jonny has a strong
                    preference for comedy, and Kimi prefers horror movies but also enjoys watching comedy from time to
                    time. To find the best movie that everyone will enjoy, you are going to use a recommender system
                    based on the Matrix Factorization techniques described above.
                </p>
                <p class="example_text">
                    <u>How to use</u>: adjust your preferences on the movie genres (comedy and horror) and then
                    click on <q>Calculate Matrix Factorization</q> to see how your preferences are alligned with the one
                    of your friends.
                </p>
                <p class="example_text">
                    <u>How to read the results</u>: to facilitate the decision of which movie to watch, you just need to
                    look at the
                    last row of the Matrix Factorization that represent the average of the predictive rating.
                </p>
                <div class="row">
                    <div class="column"></div>
                    <div class="column">
                        <p>Comedy preference:</p>
                        <input type="range" name="mySlider" id=comedySlider class="comedySlider" min="0.1" max="0.9"
                            step="0.1" value="0.5" , onchange="updateUserWeightComedy(this.value)">
                    </div>
                    <div class="column">
                        <p>Horror preference:</p>
                        <input type="range" name="mySlider" id=horrorSlider class="horrorSlider" min="0.1" max="0.9"
                            step="0.1" value="0.5" , onchange="updateUserWeightHorror(this.value)">
                    </div>
                </div>

                <table id="user_feature" class="user_table">
                    <tr>
                        <th>User</th>
                        <th>Comedy</th>
                        <th>Horror</th>
                    </tr>
                    <tr>
                        <td>Anna</td>
                        <td>0.6</td>
                        <td>0.5</td>
                    </tr>
                    <tr>
                        <td>Jonny</td>
                        <td>0.7</td>
                        <td>0.1</td>
                    </tr>
                    <tr>
                        <td>Kimi</td>
                        <td>0.4</td>
                        <td>0.9</td>
                    </tr>
                    <tr>
                        <td>You</td>
                        <td>0.5</td>
                        <td>0.5</td>
                    </tr>
                </table>

                <table id="item_feature" class="item_table">
                    <tr>
                        <th>Item</th>
                        <th>Comedy</th>
                        <th>Horror</th>
                    </tr>
                    <tr>
                        <td>Zombieland</td>
                        <td>3</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>Modern Times</td>
                        <td>5</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>The Grudge</td>
                        <td>1</td>
                        <td>5</td>
                    </tr>
                </table>

                <button id="MF_calculate" class="MF_button" type="button" onclick="calculateMatrixFact()">Calculate
                    Matrix Factorization</button>

                <p></p>

                <table id="matrix_factorization" class="rec_table">
                    <!-- <tr>
                        <th>User</th>
                        <th>Zombieland</th>
                        <th>Modern Times</th>
                        <th>The Grudge</th>
                    </tr> -->
                </table>
                <p></p>
            </div>

            <p></p>

            <p>
                While Matrix Factorization can produces some good results in a small amount of time, this methods has
                the following main disavantages:
            <ul class="fa-ul">
                <li><i class='fa-li fa fa-minus-circle'></i><b>Cold start problem</b>: the matrix can not handle fresh
                    items, such as new movies or new users.
                </li>
                <li>
                    <i class='fa-li fa fa-minus-circle'></i>
                    </class><b>The relevance of recommendation</b>: Matrix Factorization uses the dot product to
                    recommend the items, if all the users have interact with the same item, the recommendation will
                    focus on that item.
                </li>
                <li><i class='fa-li fa fa-minus-circle'></i><b>Hard feature encoding</b>: to generate the
                    recommendation, we have to explicitly provide the system with the user preference and item features.
                </li>
            </ul>
            </p>

            <h2>Modern Recommender Systems</h2>
            <p>
                Modern recommender systems have to consider many features that can be:
            </p>
            <ul>
                <li><b>Categorical</b> like userID, itemID, brand, genre, language, etc.;</li>
                <li><b>Numerical</b> like price, delivery time, number of reviews, avg of the reviews, etc.;</li>
                <li><b>Unstructured</b> like keywords, colors, material, etc.</li>
            </ul>

            <!-- <div class="example">
            <p></p>
            <p class="example_text">
                Before diving in discovering how modern recommender systems are able to generate recommendation,
                choose your occupation and one movie from the list. We will use these two information to first generate
                a movie recommendation for you and then to show how your profile is mapped in a user-desing space.
            </p>
            <label for="occupation" class="occupation">Choose your occupation:</label>
            <select name="occupation" id="occupation">
                <option value="Academic">Academic</option>
                <option value="Artist">Artist</option>
                <option value="Clerical">Clerical</option>
                <option value="College/Grad student">College/Grad student</option>
                <option value="Customer service">Customer service</option>
                <option value="Doctor/Nurse">Doctor/Nurse</option>
                <option value="Executive/Managerial">Executive/Managerial</option>
                <option value="Farmer">Farmer</option>
                <option value="Homemaker">Homemaker</option>
                <option value="K-12 student">K-12 student</option>
                <option value="Lawyer">Lawyer</option>
                <option value="Other">Other</option>
                <option value="Programmer">Programmer</option>
                <option value="Retired">Retired</option>
                <option value="Sales/Marketing">Sales/Marketing</option>
                <option value="Scientist">Scientist</option>
                <option value="Self-employed">Self-employed</option>
                <option value="Technician/Engineer">Technician/Engineer</option>
                <option value="Tradesman/Craftsman">Tradesman/Craftsman</option>
                <option value="Unemployed">Unemployed</option>
                <option value="Writer">Writer</option>
            </select>
            <br>
            <form id="movieForm" autocomplete="off">
                <div class="autocomplete">
                    <label for="movie" class="movie">Choose one movie that you have watched:</label>
                    <input id="movieInput" type="text" name="movie" placeholder="Select a movie">
                </div>
            </form>
            <p></p>
        </div> -->

            <p></p>

            <h3>An embedding approach on matrix factorization: EmbeddingMF</h3>
            <p>
                In a real-world scenario, we do not explicitly know all the preferences of every user and all the
                characteristics of a movie to make a optimal recommendation.
                However, we can use gradient descent to learn the latent factors (implicit characteristics) for each
                movie and user based on user-movie ratings.
                Using the “Dot Product + Bias” approach, we first create two embedding matrices.
                (1) A user embedding matrix (U) containing a user per row and n-factors (columns) representing the
                user features.
                (2) A movie embedding matrix (M) where a row contains n-factors (columns) that describe a specific
                movie (row).
                By setting the same amount of columns in each matrix, we can multiply the two embedding matrices
                (UxMT).
                Next, we can add the user and movie bias terms. This results in the rating for users and movies.
                Since these latent factors are initialized with random numbers, the initial ratings that are
                computed by the model differ largely from the ground truth but are minimized during training.
            </p>
            <p>
                The model consists of a user matrix of size (n_users x 128) and a movie matrix of size (n_movies x
                128) and a user bias (n_users) and a movie bias (n_movies). We randomly initialize the latent factors
                for every user and movie with a mean of 0 and a standard deviation of 0.01. After the multiplication of
                users and movies we apply a sigmoid range that squeezes the results between 0 and 5.5 so the model can
                focus on learning something within this range. We trained the model over 15 epochs using the MSELoss, a
                learning rate of 0.005, and a weight decay of 0.1 which helps to prevent the model from overfitting.
            </p>
            <h3>Deep Learning Recommender System: DeepFM</h3>
            <p>
                The adoption of deep learning models has been on the rise in every domain, including recommender
                system.
                The first model that generated state of the art (SOTA) results was Wide&Deep [5], a deep learning
                model made by Google in 2016. A complete timeline of SOTA model can be seen in the figure below. For the
                goal of this article, we are going to consider as a deep learning model, the Factorization-Machine based
                neural network (DeepFM), developed by Huawei in 2017 [6].
            </p>

            <!-- <h3>DeepFM</h3> -->
            <p>
                Architecturally DeepFM consists of two components, a Factorization Machine (FM) component and a deep
                component that share the same input. For a feature <i>i</i>, a scale <i>w<sub>i</sub></i> is used to
                weigh its order-1 (linear) importance , a laten vector <i>V<sub>i</sub></i> is used to measure its
                impact of interactions with other features. The laten vector is then fed in the FM component to model
                order-2 (pairwise) feature interactions.
                The result of this is then fed in the deep component to model the high-order feature interactions.
                all parameters are trained joyintly for the combined prediction that is represented by the following
                formula:
            </p>
            <span class="katex-display">
                <span class="katex">
                    <span class="katex-mathmk">
                        <math>
                            <semantics>
                                <mrow>
                                    <mi>y</mi>
                                    <mo>=</mo>
                                    <mi>sigmoid</mi>
                                    <mo>(</mo>
                                    <msub>
                                        <mi>y</mi>
                                        <mi>FM</mi>
                                    </msub>
                                    <mo>+</mo>
                                    <msub>
                                        <mi>y</mi>
                                        <mi>DNN</mi>
                                    </msub>
                                    <mo>)</mo>
                                </mrow>
                            </semantics>
                        </math>
                    </span>
                </span>
            </span>
            <p>
                A visual representation of the architecture is shown in the image above.
            </p>
            <p>
                <b>Factorization Machines</b> Are model class that combines the advantages of Support Vector
                Machines (SVM) with factorization models [7]. Factorization Machine are are a general predictor that
                model all interactions between variables using factorized parameters. By doing so, they are able to
                estimate interactions even in problems with huge sparsisty as is the case in recommender systems.
            </p>

            <p>
                <b>Deep component</b> The deep component is a feed-forward neural network which is used to learn
                high-order
                feature interactions. Two interesting feature of this deep learning structure are:
            <ol>
                <li>While the lengths of different input field vectors can be different, thei embedding are of the
                    same size.</li>
                <li>The latent feature vectors, output of the FM, is now use as network weights which are learned
                    and used to compress the input fields vector to the embedding vectors. </li>
            </ol>
            </p>

            <p style="color: red;">
                TODO: add figure about DeepFM architecture.
            </p>

            <h2>One recommender can not rule them all: <q>All models are wrong, but some are useful</q></h2>
            <p>
                We have trained the two models described above, the EmbeddingFM and the DeepFM, with the task of
                generating a recommendation to a test set of 100k entries. By plotting the distribution of the true and
                predictive rating, see figure below, it is possible to notice that the distribution of the DeepFM is
                skewed towards the rating 3, while the one of the EmbeddingFM is skewed towards the 4 as the true
                ratings.
            </p>
            <div id="tester2" style="width:770px;height:700px;"></div>
            <figcaption>TODO</figcaption>
            <p></p>
            <p>
                To better understand these results, we decide to validate our approaches using the Root Mean Squared
                Error (RMSE), one of the most used metrics in the Recommender System field. RMSE is typically used when
                the developer wants to evaluate a predicted score, like the predictive rating of a movie, and compare it
                to a ground truth (true rating). Compared to other metrics, RMSE but more emphasis on larger absolute
                error. Lower RMSE better is the recommendation accuracy [1, 8].
            </p>
            <span class="katex-display">
                <span class="katex">
                    <span class="katex-mathmk">
                        <math>
                            <semantics>
                                <mrow>
                                    <mi>RMSE</mi>
                                    <mo>=</mo>
                                    <mo>&#8730</mo>
                                    <mo>\frac{1}{R}</mo>
                                    <msub>
                                        <mo>&#8721</mo>
                                        <msub>
                                            <mi>r</mi>
                                            <mi>ui</mi>
                                        </msub>
                                    </msub>
                                    <mo>(</mo>
                                    <msub>
                                        <mi>r</mi>
                                        <mi>ui</mi>
                                    </msub>
                                    <mo>-</mo>
                                    <msub>
                                        <mi>r</mi>
                                        <mi>ui</mi>
                                    </msub>
                                    <msup>
                                        <mo>)</mo>
                                        <mi>2</mi>
                                    </msup>
                                </mrow>
                            </semantics>
                        </math>
                    </span>
                </span>
            </span>
            <p>
                By plotting the RMSE of the two models it is possible to notice that both the two models described
                above present a high RMSE value at the two extremes (prediction rating of 1 or 2 and rating of 5). While
                the error on rating 1 and 2 can be explained considering that <q>people are more willing to share
                    positive
                    experiences than negative ones</q> [9].
            </p>

            <div id="tester" style="width:750px;height:700px;"></div>
            <figcaption>TODO</figcaption>
            <p></p>
            <p>
                We define a perfect recommendation systems as system that will recommend only movies that the
                user will 100% like and rate as 5. The above plot, on the contrary, it shows that both models are
                not perfect in recommending that kind of movies. Based on this evidence and our definition of perfect
                recommender system, we decide to use the explain by example methodology to explain how the two
                models generate the movie recommendations for a user that are predicted with a rating of 5.
            </p>
            <p>

            </p>
            <p>
                To support this direction, we are going to use a custom Venn Diagram with three sets: true rating
                (movie rated 5 by the users), predicted ratings from the embedding matrix factorization, and predicted
                ratings from the DeepFM model.
            </p>
            <p>
                SOMETHING MISSING HERE
            </p>
            <div class="row">
                <div class="centered">
                    <img src="how-to-venn.png" height="450px">
                </div>
            </div>
            <figcaption class="centered">
                Description of the different areas of the Venn Diagram.
            </figcaption>

            <p></p>
            <div class="example">
                <p class="example_text">
                    <u>How to read:</u> the movies are represented by dot in the different sets of the Venn Diagram. The
                    line that starts from the center represent the error that has been made.
                <div class="row">
                    <div class="column example_text">
                        <p class="example_text"><b>EmbeddingFM</b></p>
                    </div>
                    <div class="column">
                        <p class="example_text"><b>DeepFM</b></p>
                    </div>
                    <div class="column">

                    </div>
                </div>
                <div class="row">
                    <div class="column example_text">
                        <img src="embeddingfm-error1.png" width="100px">
                    </div>
                    <div class="column example_text">
                        <img src="deepfm-error1.png" width="100px">
                    </div>
                    <div class="column-text">
                        <p>The model over estimate the rating that the user will give.</p>
                    </div>
                </div>
                <div class="row">
                    <div class="column example_text">
                        <img src="embeddingfm-error2.png" width="100px">
                    </div>
                    <div class="column example_text">
                        <img src="deepfm-error2.png" width="100px">
                    </div>
                    <div class="column-text">
                        <p>The model under estimate the rating that the user will give.</p>
                    </div>
                </div>
                </p>
                <p class="example_text">
                    <u>How to interact:</u> Lay over one of the point to discover what is the movie name and the
                    predicted score.
                </p>
                <div id='myDiv'></div>
            </div>

            <p></p>
            <p>
                Of the above plot, what it is interesting to notice are the movies in the bottom left of the true
                rating set and the movies in the intersection between the two recommendation systems. The first movies
                represent movies that the user has liked and rate 5 but both models will not recommend to the user. The
                latter ones, is a movie that both models think that the user will like and rate 5 but in reality the
                users will not like.
            </p>
            <p>
                To explore more in details the case where the movie recommended and the user preferences do
                not overlap we can plot the rating distribution on the training data together with the user
                rating. If we consider the case about the movies that are recommended but the user will not like, it is
                possible to see is that the model suffer from some kind of bias that is propagate starting form the
                training data, like the movie is very popular across the other users that the dataset includes in the
                training data. For the other case we can see that the movie that the user like but the recommender is
                not recommending to him/her are movies that in the training data have not good rating (mean of 2.24).
            </p>

            <h2>Conclusion</h2>
            <p>
                While recommender systems aims in generating a personalized experience on the web, the model are not
                trained on a single user but on a group. With this article we have shows that ....
                Thanks to this explnation we tried to show that if the focus shift from data/model centric to more
                human centric the models are not really generate personalized recommendations.
            </p>
    </d-article>

    <d-appendix>
        <h3>Acknowledgments</h3>
        <p>Text</p>
        <h3>Further Reading</h3>
        <p>text</p>
        <h3>References</h3>
        <p>
            [1] Ricci, Francesco, Lior Rokach, and Bracha Shapira. "Introduction to recommender systems handbook."
            Recommender systems handbook. Springer, Boston, MA, 2011. 1-35.
        </p>
        <p>
            [2] Koren, Yehuda, Robert Bell, and Chris Volinsky. "Matrix factorization techniques for recommender
            systems." Computer 42.8 (2009): 30-37.
        </p>
        <p>
            [3] Lee, Daniel D., and H. Sebastian Seung. "Learning the parts of objects by non-negative matrix
            factorization." Nature 401.6755 (1999): 788-791.
        </p>
        <p>
            [4] Glauber, Rafael, and Angelo Loula. "Collaborative filtering vs. content-based filtering: differences and
            similarities." arXiv preprint arXiv:1912.08932 (2019).
        </p>
        <p>
            [5] Cheng, Heng-Tze, et al. "Wide & deep learning for recommender systems." Proceedings of the 1st workshop
            on deep learning for recommender systems. 2016.
        </p>
        <p>
            [6] Guo, Huifeng, et al. "DeepFM: a factorization-machine based neural network for CTR prediction." arXiv
            preprint arXiv:1703.04247 (2017).
        </p>
        <p>
            [7] Rendle, Steffen. "Factorization machines." 2010 IEEE International conference on data mining. IEEE,
            2010.
        </p>
        <p>
            [8] Isinkaye, Folasade Olubusola, Yetunde O. Folajimi, and Bolande Adefowoke Ojokoh. "Recommendation
            systems: Principles, methods and evaluation." Egyptian informatics journal 16.3 (2015): 261-273.
        </p>
        <p>
            [9] 2018 Customer Experience, https://www.sitel.com/report/2018-cx-index/
        </p>
        <h3>Reuse</h3>
        <p>
            Diagrams and text are licensed under Creative Commons Attribution CC-BY 4.0 with the source available on
            GitHub, unless noted otherwise. The figures that have been reused from other sources don’t fall under this
            license and can be recognized by a note in their caption: “Figure from …”.
        </p>

    </d-appendix>

    <script>

        var e = document.getElementById('parent');
        e.onmouseover = function () {
            document.getElementById('popup').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup').style.display = 'none';
        }

        var e = document.getElementById('parent2');
        e.onmouseover = function () {
            document.getElementById('popup2').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup2').style.display = 'none';
        }

        var e = document.getElementById('parent3');
        e.onmouseover = function () {
            document.getElementById('popup3').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup3').style.display = 'none';
        }

        var e = document.getElementById('parent4');
        e.onmouseover = function () {
            document.getElementById('popup4').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup4').style.display = 'none';
        }

        var e = document.getElementById('parent5');
        e.onmouseover = function () {
            document.getElementById('popup5').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup5').style.display = 'none';
        }

        var e = document.getElementById('parent6');
        e.onmouseover = function () {
            document.getElementById('popup6').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup6').style.display = 'none';
        }

        var e = document.getElementById('parent7');
        e.onmouseover = function () {
            document.getElementById('popup7').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup7').style.display = 'none';
        }

        function updateUserWeightComedy(slideAmount) {
            //  to retrieve the value of the slider and display it
            //	var sliderDiv = document.getElementById("sliderAmount");
            //  sliderDiv.innerHTML = slideAmount;

            var cell_change = document.getElementById("user_feature").rows[4].cells;
            // console.log(cell_change)
            cell_change[1].innerHTML = slideAmount;
            // to save the new array
            CacheValues();
        }

        function updateUserWeightHorror(slideAmount) {
            //  to retrieve the value of the slider and display it
            //	var sliderDiv = document.getElementById("sliderAmount");
            //  sliderDiv.innerHTML = slideAmount;

            var cell_change = document.getElementById("user_feature").rows[4].cells;
            // console.log(cell_change)
            cell_change[2].innerHTML = slideAmount;
            // to save the new array
            CacheValues();
        }

        function createGroups(arr, numGroups) {
            const perGroup = Math.ceil(arr.length / numGroups);
            return new Array(numGroups)
                .fill('')
                .map((_, i) => arr.slice(i * perGroup, (i + 1) * perGroup));
        }

        // create an empty array to store the values
        var matrix_user = [];
        var matrix_score = [];

        function CacheValues() {

            matrix_user = [];
            matrix_score = [];

            // retrieve all the code of the table
            var user_table = document.getElementById("user_feature");
            var score_table = document.getElementById("item_feature");

            // get length of the rows
            var row_length = user_table.rows.length;
            var score_row_length = score_table.rows.length;

            for (let i = 1; i < row_length; i++) {
                // retrieve cells info
                var table_cells = user_table.rows.item(i).cells;

                // gets amount of cells of current row
                var col_length = table_cells.length;

                for (var j = 0; j < col_length; j++) {
                    // get cell info here 
                    var cell_value = table_cells.item(j).innerHTML;
                    // console.log(cell_value)
                    // push every row value in the empty matrix
                    matrix_user.push(cell_value);
                }
            }

            for (let i = 1; i < score_row_length; i++) {
                // retrieve cells info
                var score_table_cells = score_table.rows.item(i).cells;

                // gets amount of cells of current row
                var score_col_length = score_table_cells.length;

                for (var j = 0; j < score_col_length; j++) {
                    // get cell info here 
                    var score_cell_value = score_table_cells.item(j).innerHTML;
                    matrix_score.push(score_cell_value);
                }
            }
            return {
                mu: matrix_user,
                ms: matrix_score
            }
        }

        function calculateMatrixFact() {

            var cache = CacheValues();

            // split the matrix into arrays one for each user and movie
            var user_matrix = createGroups(cache.mu, 4);
            // console.log(user_matrix);
            var score_matrix = createGroups(cache.ms, 3);
            //console.log(score_matrix);

            // remove the string user_name and movie_name
            for (let i = 0; i < user_matrix.length; i++) {
                user_matrix[i].shift();
            }

            for (let j = 0; j < score_matrix.length; j++) {
                score_matrix[j].shift();
            }

            var dot_matrix = [];
            var scores = [];
            var average_one = [];
            var average_two = [];
            var average_three = [];

            // perform the dot product
            for (let j = 0; j < user_matrix.length; j++) {
                for (let k = 0; k < score_matrix.length; k++) {
                    //console.log(user_matrix[j])
                    //console.log(score_matrix[k])
                    var dot_product = (math.multiply(user_matrix[j], score_matrix[k])).toFixed(1);
                    //console.log(dot_product)
                    dot_matrix.push(dot_product);
                }
            }

            for (let i = 0; i < dot_matrix.length; i++) {
                scores.push(dot_matrix[i])
            }
            for (let j = 0; j < scores.length; j += 3) {
                average_one.push(scores[j]);
            }
            for (let j = 1; j < scores.length; j += 3) {
                average_two.push(scores[j]);
            }
            for (let j = 2; j < scores.length; j += 3) {
                average_three.push(scores[j]);
            }
            var avg_one = math.mean(average_one).toFixed(1);
            var avg_two = math.mean(average_two).toFixed(1);
            var avg_three = math.mean(average_three).toFixed(1);

            dot_matrix.push(avg_one, avg_two, avg_three)

            // create the matrix and push back the string (first column of the table)
            var dot_prod_matrix = createGroups(dot_matrix, 5);
            dot_prod_matrix[0].unshift("Anna");
            dot_prod_matrix[1].unshift("Jonny");
            dot_prod_matrix[2].unshift("Kimi");
            dot_prod_matrix[3].unshift("You");
            dot_prod_matrix[4].unshift("Average")

            // from array to HTML table
            fetch = document.getElementById('matrix_factorization');
            fetch.innerHTML = `<tr>
            <th>User</th>
            <th>Zombieland</th>
            <th>Modern Times</th>
            <th>The Grudge</th>
             </tr>`;

            for (var i = 0; i < dot_prod_matrix.length; i++) {
                var newRow = fetch.insertRow(fetch.length);
                for (var j = 0; j < dot_prod_matrix[i].length; j++) {
                    var cell = newRow.insertCell(j);
                    cell.innerHTML = dot_prod_matrix[i][j];
                }
            }

        }

        // function autocomplete(inp, arr) {
        //     /*the autocomplete function takes two arguments,
        //     the text field element and an array of possible autocompleted values:*/
        //     var currentFocus;
        //     /*execute a function when someone writes in the text field:*/
        //     inp.addEventListener("input", function (e) {
        //         var a, b, i, val = this.value;
        //         /*close any already open lists of autocompleted values*/
        //         closeAllLists();
        //         if (!val) { return false; }
        //         currentFocus = -1;
        //         /*create a DIV element that will contain the items (values):*/
        //         a = document.createElement("DIV");
        //         a.setAttribute("id", this.id + "autocomplete-list");
        //         a.setAttribute("class", "autocomplete-items");
        //         /*append the DIV element as a child of the autocomplete container:*/
        //         this.parentNode.appendChild(a);
        //         /*for each item in the array...*/
        //         for (i = 0; i < arr.length; i++) {
        //             /*check if the item starts with the same letters as the text field value:*/
        //             if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
        //                 /*create a DIV element for each matching element:*/
        //                 b = document.createElement("DIV");
        //                 /*make the matching letters bold:*/
        //                 b.innerHTML = "<strong>" + arr[i].substr(0, val.length) + "</strong>";
        //                 b.innerHTML += arr[i].substr(val.length);
        //                 /*insert a input field that will hold the current array item's value:*/
        //                 b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
        //                 /*execute a function when someone clicks on the item value (DIV element):*/
        //                 b.addEventListener("click", function (e) {
        //                     /*insert the value for the autocomplete text field:*/
        //                     inp.value = this.getElementsByTagName("input")[0].value;
        //                     /*close the list of autocompleted values,
        //                     (or any other open lists of autocompleted values:*/
        //                     closeAllLists();
        //                 });
        //                 a.appendChild(b);
        //             }
        //         }
        //     });
        //     /*execute a function presses a key on the keyboard:*/
        //     inp.addEventListener("keydown", function (e) {
        //         var x = document.getElementById(this.id + "autocomplete-list");
        //         if (x) x = x.getElementsByTagName("div");
        //         if (e.keyCode == 40) {
        //             /*If the arrow DOWN key is pressed,
        //             increase the currentFocus variable:*/
        //             currentFocus++;
        //             /*and and make the current item more visible:*/
        //             addActive(x);
        //         } else if (e.keyCode == 38) { //up
        //             /*If the arrow UP key is pressed,
        //             decrease the currentFocus variable:*/
        //             currentFocus--;
        //             /*and and make the current item more visible:*/
        //             addActive(x);
        //         } else if (e.keyCode == 13) {
        //             /*If the ENTER key is pressed, prevent the form from being submitted,*/
        //             e.preventDefault();
        //             if (currentFocus > -1) {
        //                 /*and simulate a click on the "active" item:*/
        //                 if (x) x[currentFocus].click();
        //             }
        //         }
        //     });
        //     function addActive(x) {
        //         /*a function to classify an item as "active":*/
        //         if (!x) return false;
        //         /*start by removing the "active" class on all items:*/
        //         removeActive(x);
        //         if (currentFocus >= x.length) currentFocus = 0;
        //         if (currentFocus < 0) currentFocus = (x.length - 1);
        //         /*add class "autocomplete-active":*/
        //         x[currentFocus].classList.add("autocomplete-active");
        //     }
        //     function removeActive(x) {
        //         /*a function to remove the "active" class from all autocomplete items:*/
        //         for (var i = 0; i < x.length; i++) {
        //             x[i].classList.remove("autocomplete-active");
        //         }
        //     }
        //     function closeAllLists(elmnt) {
        //         /*close all autocomplete lists in the document,
        //         except the one passed as an argument:*/
        //         var x = document.getElementsByClassName("autocomplete-items");
        //         for (var i = 0; i < x.length; i++) {
        //             if (elmnt != x[i] && elmnt != inp) {
        //                 x[i].parentNode.removeChild(x[i]);
        //             }
        //         }
        //     }
        //     /*execute a function when someone clicks in the document:*/
        //     document.addEventListener("click", function (e) {
        //         closeAllLists(e.target);
        //     });
        // }

        // autocomplete(document.getElementById("movieInput"), movie_array);

        TESTER = document.getElementById('tester');
        TESTER2 = document.getElementById('tester2');
        function unpack(row, key) {
            return row.map(function (row) { return row[key] });
        }

        // Error plot //
        var drawChartError = async () => {

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/nn_rmse_df.csv",
                function (rows) {
                    return {
                        rmse: rows.rmse,
                        rating: rows.rating
                    }
                }).then(
                    function (rows) {

                        var x = unpack(rows, 'rating')
                        var y = unpack(rows, 'rmse')

                        console.log(x)
                        console.log(y)
                        var errors_nn = {
                            name: 'Embeddings Only',
                            x: x,
                            y: y,
                            type: "scatter",
                            mode: "lines+markers",
                            line: { shape: 'spline' },
                            fill: 'tozeroy',
                            fillcolor: 'rgba(57, 45, 50, 0.3)',
                            marker: { color: "#392d32" },
                            hovertemplate: '<b>RMSE: %{y:.2f}</b>' +
                                '<br>True Rating: %{x}<br>'
                        };
                        var layout = {
                            title: {
                                text: "Distribution of Root Mean Squared Errors: <br><i>Embeddings Only vs. DeepFM</i>",
                                font: {
                                    size: 20
                                },
                                xref: 'paper',
                                x: 0.01,

                            },
                            xaxis: {
                                title: "<b>True Rating (Categorical)<b>"
                            },
                            yaxis: {
                                title: "<b>RMSE</b>"
                            },
                            showlegend: true,
                            legend: {
                                "orientation": "h",
                                x: 1,
                                xanchor: 'right',
                                y: 1
                            }

                        };
                        var config = { responsive: true, displayModeBar: false };

                        if (document.getElementById("tester")) {
                            Plotly.newPlot(TESTER, [errors_nn], layout, config)

                        }

                    }
                )

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/deepfm_rmse_df.csv",
                function (rows) {
                    return {
                        rmse: rows.rmse

                    }
                }).then(
                    function (rows) {
                        var y = unpack(rows, 'rmse')
                        //https://coolors.co/211a1d-f4c3c2-f49f0a-c7f0bd-81adc8

                        console.log(y)
                        var errors_deepfm = {
                            name: 'DeepFM',
                            x: [1, 2, 3, 4, 5],
                            y: y,
                            type: "scatter",
                            mode: "lines+markers",
                            line: { shape: 'spline' },
                            fill: 'tozeroy',
                            fillcolor: 'rgba(244, 159, 10, 0.6)',
                            marker: { color: "#F49F0A" },
                            hovertemplate: '<b>RMSE: %{y:.2f}</b>' +
                                '<br>True Rating: %{x}<br>'

                        };

                        var config = { responsive: true };

                        if (document.getElementById("tester")) {
                            Plotly.addTraces(TESTER, errors_deepfm, 0)

                        }

                    }
                )

        }
        if (document.getElementById('tester')) {
            drawChartError();
        }


        // Density Plot //
        var drawChartDensity = async () => {

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/ratings_val.csv",
                function (rows) {
                    return {
                        true_rating: rows.true_rating,
                        pred_rating: rows.pred_rating
                    }
                }).then(
                    function (rows) {

                        var y1 = unpack(rows, 'true_rating')
                        var y2 = unpack(rows, 'pred_rating')
                        //https://coolors.co/211a1d-f4c3c2-f49f0a-c7f0bd-81adc8

                        console.log(y1)
                        console.log(y2)
                        var true_ratings = {
                            name: 'True Rating',
                            x: y1,
                            type: "histogram",
                            histnorm: "density",
                            //alignmentgroup: "1",
                            //ybins:{
                            //    end: 5,
                            //    start: 1,
                            //    size:5
                            //},
                            marker: { color: "rgba(103, 141, 88, 0.5)" },
                            hoverlabel: {
                                namelength: 15
                            },
                        };
                        var embeddings_ratings = {
                            name: 'Embeddings Only (Predicted Rating)',
                            x: y2,
                            type: "histogram",
                            histnorm: "density",
                            //alignmentgroup: "1",
                            //ybins:{
                            //    end: 5,
                            //    start: 1,
                            //    
                            //},
                            marker: { color: "#392d32" },

                        };
                        var layout = {
                            title: {
                                text: "Distribution of Ratings by Model: <br><i>True vs. Embeddings Only vs. DeepFM</i>",
                                font: {
                                    size: 20
                                },
                                xref: 'paper',
                                x: 0.01,

                            },
                            xaxis: {
                                title: "<b>True Rating (Categorical (true) and Numeric (predictions))<b>"
                            },
                            yaxis: {
                                title: "<b>Count</b>"
                            },
                            showlegend: true,
                            legend: {
                                "orientation": "h",
                                x: 1,
                                xanchor: 'right',
                                y: 1
                            },
                            barmode: "overlay"

                        };
                        var config = { responsive: true, displayModeBar: false };

                        if (document.getElementById("tester2")) {
                            Plotly.newPlot(TESTER2, [embeddings_ratings, true_ratings], layout, config)

                        }

                    }
                )

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/deepFM-final-dataset.csv",
                function (rows) {
                    return {
                        pred_rating: rows.pred_rating

                    }
                }).then(
                    function (rows) {
                        var x = unpack(rows, 'pred_rating')

                        console.log(x)
                        var deepfm_ratings = {
                            name: 'DeepFM (Predicted Rating)',
                            x: x,
                            type: "histogram",
                            histnorm: "density",
                            //alignmentgroup: "1",
                            //ybins:{
                            //    end: 5,
                            //    start: 1,
                            //   
                            //},
                            marker: { color: 'rgba(244, 159, 10, 0.6)' },

                        };

                        if (document.getElementById("tester2")) {
                            Plotly.addTraces(TESTER2, deepfm_ratings, 2)

                        }

                    }
                )

        }
        if (document.getElementById('tester2')) {
            drawChartDensity();
        }

        // venn diagram
        function map_to_range(number, in_min, in_max, out_min, out_max) {
            return (((number - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min);
        }

        var in_min = -2
        var in_max = 2
        var out_min = -0.25
        var out_max = 0.25

        // trace for movies that the user likes
        var trace1 = {
            x: [0.6, 0.7, 0.8],
            y: [0.7, 1.4, 0.4],
            error: [1.58, 2.60, 0.71],
            errorIbra: [0.94, 2.93, 1.11],
            type: 'scatter',
            mode: 'markers',
            text: ['Return to Oz', "Who's That Girl?", 'Crimes and Misdemeanors'],
            deepFM_pred: [4.1, 2.1, 3.9],
            embMF_pred: [3.4, 2.4, 4.3],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 5,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'DeepFM predicted rating: %{deepFM_pred}<br>' +
                'EmbeddingMF predicted rating: %{embMF_pred}'
        };

        // trace for movie that the EmbeddingFM recommend and user liked
        var trace2 = {
            x: [1.2, 1.5,],
            y: [0.5, 0.7],
            type: 'scatter',
            mode: 'markers',
            text: ['Pulp Fiction', ' Stand by Me'],
            true_rating: [5, 5],
            embMF_pred: [4.6, 4.3],
            error: [0.4, 0.7],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'True rating: %{true_rating}<br>' +
                'EmbeddingMF predicted rating: %{embMF_pred}'

        };
        // trace for movies that the EmbeddingFM recommend (no overlap)
        var trace3 = {
            x: [2, 2.5],
            y: [0.2, 0.75],
            type: 'scatter',
            mode: 'markers',
            text: ['Network', 'Bonnie and Clyde'],
            embMF_pred: [4.56, 4.54],
            true_rating: [4, 3],
            error: [-0.56, -1.54],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'True rating: %{true_rating}<br>' +
                'EmbeddingMF predicted rating: %{embMF_pred}'

        };
        // trace for movies that DeepFM has recommended no overlap
        var trace4 = {
            x: [2, 2.2, 2.6],
            y: [2, 2.5, 2.2],
            type: 'scatter',
            mode: 'markers',
            text: ['Kingpin', 'Siren', 'Body Heat'],
            true_rating: [4, 4, 4],
            deepFM_pred: [4.63, 4.85, 4.61],
            error: [-0.63, -0.85, -0.61],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'True rating: %{true_rating}<br>' +
                'DeepFM predicted rating: %{deepFM_pred}'

        };
        // trace for movies that both systems have recommended but the user do not like
        var trace5 = {
            x: [2.2],
            y: [1.2],
            type: 'scatter',
            mode: 'markers',
            text: ['Buffy the Vampire Slayer'],
            deepFM_pred: [4.1],
            embMF_pred: [3.4],
            true_rating: [4],
            error: [-2.80],
            errorIbra: [-3.54],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'True rating: %{true_rating}' +
                'DeepFM predicted rating: %{deepFM_pred}<br>' +
                'EmbeddingMF predicted rating: %{embMF_pred}'

        };
        // trace for movies that both recommender have recommended and the user has liked
        var trace6 = {
            x: [1.7],
            y: [1.3],
            type: 'scatter',
            mode: 'markers',
            text: ['Frankenstein'],
            deepFM_pred: [4.79],
            embMF_pred: [3.36],
            error: [0.64],
            errorIbra: [0.21],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'True rating: %{true_rating}<br>' +
                'DeepFM predicted rating: %{deepFM_pred}<br>' +
                'EmbeddingMF predicted rating: %{embMF_pred}'
        };
        //movie that deepFM recommend and user likes
        var trace7 = {
            x: [1.5, 1.23, 1.69, 1.4],
            y: [1.5, 1.7, 1.54, 1.4],
            type: 'scatter',
            mode: 'markers',
            text: ['Delicatessen', 'Watership Down', 'Clueless', "The Decline of Western Civilization"],
            deepFM_pred: [4.58, 4.54, 4.7],
            true_rating: [5, 5, 5],
            error: [0.41, 0.45, 0.46, 0.29],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text}</b><br><br>' +
                'True rating: %{true_rating}<br>' +
                'DeepFM predicted rating: %{deepFM_pred}'
        };

        var layout = {
            title: 'True & Predicted Ratings for User 1680',
            annotations: [
                {
                    x: 0.4,
                    y: 1.8,
                    xref: 'x',
                    yref: 'y',
                    text: 'Movies with a rating of 5',
                    showarrow: true,
                    arrowhead: 3,
                    ax: -30,
                    ay: -30
                },
                // {
                //   x: 1.5,
                //   y: -0.4,
                //   xref: 'x',
                //   yref: 'y',
                //   text: 'Falsely recommended by Model',
                //   showarrow: true,
                //   arrowhead: 3,
                //   ax: -50,
                //   ay: 50
                // },
                {
                    x: 2,
                    y: -0.4,
                    xref: 'x',
                    yref: 'y',
                    text: 'EmbeddingFM',
                    showarrow: false,
                    arrowhead: 3,
                    ax: -50,
                    ay: 50
                },
                {
                    x: 2,
                    y: 2.9,
                    xref: 'x',
                    yref: 'y',
                    text: 'DeepFM',
                    showarrow: false,
                    arrowhead: 3,
                    ax: -50,
                    ay: 50
                }
            ],
            xaxis: {
                range: [-0.6, 3.1],
                showticklabels: false,
                autotick: false,
                showgrid: false,
                zeroline: false
            },
            yaxis: {
                range: [-0.6, 3.1],
                showticklabels: false,
                autotick: false,
                showgrid: false,
                zeroline: false
            },
            plot_bgcolor: "rgba(0,0,0,0)",
            paper_bgcolor: "rgba(0,0,0,0)",
            showlegend: false,
            shapes: [
                {
                    opacity: 0.3,
                    xref: 'x',
                    yref: 'y',
                    fillcolor: 'rgba(0,0,0,0)',
                    x0: 0,
                    y0: 0,
                    x1: 2,
                    y1: 2,
                    type: 'circle',
                    line: {
                        color: 'green'
                    }
                }, {
                    opacity: 0.3,
                    xref: 'x',
                    yref: 'y',
                    fillcolor: "rgba(0,0,0,0)",
                    x0: 1,
                    y0: -0.5,
                    x1: 3,
                    y1: 1.5,
                    type: 'circle',
                    line: {
                        color: '#F6A720',
                    }
                },
                {
                    opacity: 0.3,
                    xref: 'x',
                    yref: 'y',
                    fillcolor: 'rgba(0,0,0,0)',
                    x0: 1,
                    y0: 1,
                    x1: 3,
                    y1: 3,
                    type: 'circle',
                    line: {
                        color: '#392D32'
                    }
                }
            ],
            margin: {
                l: 35,
                r: 35,
                b: 35,
                t: 35
            },
            height: 700,
            width: 700
        };

        var data = [trace1, trace2, trace3, trace4, trace5, trace6, trace7];

        function addLinesAndCirclesModelYves(trace) {
            for (var i = 0; i < trace.x.length; i++) {
                layout.shapes.push({
                    type: 'line',
                    x0: trace.x[i],
                    y0: trace.y[i],
                    x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                    y1: trace.y[i],
                    opacity: 0.7,
                    line: {
                        color: 'red',
                        width: 1.5
                    }
                },
                    {
                        opacity: 0.3,
                        xref: 'x',
                        yref: 'y',
                        fillcolor: '#F6A720',
                        x0: trace.x[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y0: trace.y[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y1: trace.y[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        type: 'circle',
                        line: {
                            color: 'black'
                        }
                    })
            }
        }

        function addLinesAndCirclesModelYvesAndIbra(trace) {
            for (var i = 0; i < trace.x.length; i++) {
                layout.shapes.push({
                    type: 'line',
                    x0: trace.x[i],
                    y0: trace.y[i],
                    x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                    y1: trace.y[i],
                    opacity: 0.7,
                    line: {
                        color: 'red',
                        width: 1.5
                    }
                },
                    {
                        type: 'line',
                        x0: trace.x[i],
                        y0: trace.y[i],
                        x1: trace.x[i],
                        y1: trace.y[i] + map_to_range(trace.errorIbra[i], in_min, in_max, out_min, out_max),
                        opacity: 0.7,
                        line: {
                            color: 'red',
                            width: 1.5
                        }
                    },
                    {
                        opacity: 0.3,
                        xref: 'x',
                        yref: 'y',
                        fillcolor: 'rgba(0,0,0,0)',
                        x0: trace.x[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y0: trace.y[i] - map_to_range(trace.errorIbra[i], in_min, in_max, out_min, out_max),
                        x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y1: trace.y[i] + map_to_range(trace.errorIbra[i], in_min, in_max, out_min, out_max),
                        type: 'circle',
                        line: {
                            color: 'black'
                        }
                    })
            }
        }


        function addLinesAndCirclesModelIbra(trace) {
            for (var i = 0; i < trace.x.length; i++) {
                layout.shapes.push({
                    type: 'line',
                    x0: trace.x[i],
                    y0: trace.y[i],
                    x1: trace.x[i],
                    y1: trace.y[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                    opacity: 0.7,
                    line: {
                        color: 'red',
                        width: 1.5
                    }
                },
                    {
                        opacity: 0.3,
                        xref: 'x',
                        yref: 'y',
                        fillcolor: '#392D32',
                        x0: trace.x[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y0: trace.y[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y1: trace.y[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        type: 'circle',
                        line: {
                            color: 'black'
                        }
                    })
            }
        }
        addLinesAndCirclesModelYvesAndIbra(trace1)
        addLinesAndCirclesModelYves(trace3)
        addLinesAndCirclesModelYves(trace2)
        addLinesAndCirclesModelIbra(trace4)
        addLinesAndCirclesModelYvesAndIbra(trace5)
        addLinesAndCirclesModelYvesAndIbra(trace6)
        addLinesAndCirclesModelIbra(trace7)


        Plotly.newPlot('myDiv', data, layout, { displayModeBar: false });

    </script>
</body>