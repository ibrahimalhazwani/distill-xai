<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">

    <head>
        <script src="https://distill.pub/template.v2.js"></script>
        <script src="https://cdnjs.com/libraries/mathjs"></script>
        <script src="https://unpkg.com/mathjs@10.6.3/lib/browser/math.js"></script>

        <script src="https://cdn.plot.ly/plotly-2.12.1.min.js"></script>
        <script src="plotly-2.12.1.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>

        <!-- Load CSS file. -->
        <link rel="stylesheet" href="style.css">
    </head>

<body distill-prerendered="">
    <distill-header distill-prerendered="">
        <div class="content">
            <a class="logo" href="/">
                <svg viewBox="-607 419 64 64">
                    <path
                        d="M-573.4,478.9c-8,0-14.6-6.4-14.6-14.5s14.6-25.9,14.6-40.8c0,14.9,14.6,32.8,14.6,40.8S-565.4,478.9-573.4,478.9z">
                    </path>
                </svg>
                Distil
            </a>
            <nav class="nav">
                <a href="/about/">About</a>
                <a href="/prize/">Prize</a>
                <a href="/journal/">Submit</a>
            </nav>
        </div>
    </distill-header>

    <d-title style="padding-bottom: 0">
        <h1>What is it next?</h1>
        <p>How recommender systems choose the next item.</p>
        <d-figure class="l-screen shade-figure" style="border-bottom: none">
        </d-figure>
    </d-title>

    <d-byline>
        <div class="byline grid">
            <div class="authors-affiliations grid">
                <h3>Authors</h3>
                <h3>Affiliations</h3>
                <p class="author">
                    Ibrahim Al-Hazwani
                </p>
                <p class="affiliation">
                    University of Zurich and UZH Digital Society Initiative
                </p>
                <p class="author">
                    Gabriela Morgenshtern
                </p>
                <p class="affiliation">
                    University of Zurich
                </p>
                <p class="author">
                    Yves Rutishauser
                </p>
                <p class="affiliation">
                    University of Zurich
                </p>

                <p class="author">
                    Menna El-Assady
                </p>
                <p class="affiliation">
                    ETH Zürich
                </p>
                <p class="author">
                    Jürgen Bernard
                </p>
                <p class="affiliation">
                    University of Zurich and UZH Digital Society Initiative
                </p>
            </div>
            <div>
                <h3>Published</h3>
                <p>TBA</p>
            </div>
            <div>
                <h3>DOI</h3>
                <p>TBA</p>
            </div>
        </div>
    </d-byline>

    <d-article>
        <div class="centered">
            <img src='rs-timeline.png' width="700px" height="187px">
        </div>
        <figcaption class="centered">
            Timeline of recommender systems. Highlighted are the two methods described in this article. A clear
            distinction between pre and post deep learning era is on the year 2012.
        </figcaption>
        <p></p>
        <p>If you have ever used an e-commerce service or a streaming platform, you have already seen at least
            one of these: <q><i>recommended for you</i></q>, or <q><i>other users have also bought this</i></q>. In
            this article, we will give you an introduction to Recommender Systems (RS), and illustrate how new
            deep-learning algorithmic techniques in this field work.
        </p>

        <p>
            First, we illustrate how Matrix Factorization (MF), a relatively simply designed
            recommender system, works. Then, we increase the sophistication of our approach, exploring
            the effect this has on the prediction accuracy of a model.

            We explain differences in two models' competence in predicting a user's rating of movies they have seen
            by leveraging various visualization strategies. Through this article, we hope
            that you will gain intuition and visual understanding of how recommender systems work.
        </p>


        <!--
            <d-cite key="ricci2011introduction">
                <d-hover-box id="hover-box" style="display: none;">
                    <ul>
                        <li>
                            <strong>Introduction to recommender systems handbook</strong>
                            <a href="https://doi.org/10.1007/978-0-387-85820-3_1"></a>
                            <br> F. Ricci, L. Rokach, B. Shapira
                            <br> Recommender Systems Handbook. Springer, Boston, MA.
                            <a href="https://doi.org/10.1007/978-0-387-85820-3_1" style="text-decoration: inherit;">DOI: 10.1007/978-0-387-85820-3_1 </a>
                        </li>
                    </ul>
                </d-hover-box>
                <div id="citation-" class="citation">
                    <span class="citation-number">[1]</span>
                </div>
            </d-cite>
        -->
        </p>


        <h2>Recommender systems: what are they?</h2>

        <!-- <img src='rs-workflow2.png' width="700px"> -->
        <p>
            Recommender systems are defined as techniques that suggest items
            for a given user to interact with [1]. Usually, and so especially on the web, recommendations are
            personalized to the specific user interacting with the system. By <q><i>item</i></q>, we refer to
            <i>what</i> the system is recommending to the user. This item could be the next movie you watch, song
            you listen to, the fastest path to your next destination, or your next date!
        </p>
        <p>
            The recommendation process can be divided into four steps: querying, retrieving, filtering, scoring, and
            ranking.
        </p>
        <div class="example-rs">
            <p></p>
            <p class="example_text">
                <i><b>This box is interactive!</b> Hover over the different steps below to learn more </i>
            </p>
            <div class="row">
                <div class="column-rs">
                    <figcaption>
                        Query the database
                    </figcaption>
                </div>
                <div class="column-rs">
                    <figcaption>
                        Retrieval
                    </figcaption>
                </div>
                <div class="column-rs">
                    <figcaption>
                        Filtering
                    </figcaption>
                </div>
                <div class="column-rs">
                    <figcaption>
                        Scoring and ranking
                    </figcaption>
                </div>
            </div>
            <div class="row">
                <div class="column-rs">
                    <div id="parent">
                        <img src="avatar-rs-workflow.png" width="150px">
                        <div id="popup" style="display: None">
                            The recommendation process starts when a user makes a query to an online platflorm
                        </div>
                    </div>
                </div>
                <div class="column-rs-cloud">
                    <div id="parent2">
                        <img src="retrieve-rs-workflow.png" width="150px">
                        <div id="popup2" style="display: None">
                            Items are retrieved based on the query. Their order is arbitrary.
                        </div>
                    </div>
                </div>
                <div class="column-rs">
                    <div id="parent3">
                        <img src="filter-rs-workflow.png" width="150px">
                        <div id="popup3" style="display: None">
                            The items retrieved are filtered based on some set of preferences
                        </div>
                    </div>
                </div>
                <div class="column-rs">
                    <div id="parent4">
                        <img src="ranking-rs-workflow.png" width="150px">
                        <div id="popup4" style="display: None">
                            Each item is given a score, and the item rankings are returned to the user.
                            The top item is the system's recommendation.
                        </div>
                    </div>
                </div>
            </div>
            <p></p>
        </div>
        <p></p>
        <p>
            In order to generate recommendations, RS may accept input data like users' preferences,
            items' characteristics, explicit feedback, implicit feedback... Essentially,
            any measurable information about the items or users the RS is interested in modeling. When computing
            recommendations, this information is retrieved from a database and then stored in matrices. The matrix
            data object optimizes a lot of the computation required to reach a recommendation. Why this happens is
            beyond the scope of this discussion, but you can read about this process in detail here [10].
        </p>
        <p>
            The most accessible data are explicit ratings, which include explicit input from the user regarding
            their level of interest in a product, i.e. the rating a user gave to an item. Usually, explicit
            feedback can be represented by a <i><q>sparse</q></i> matrix. A sparse matrix is characterized as
            a matrix where only a small number of fields have non-zero (or non-null) values. Since users are
            unlikely to rate more than a small number of items from the entirety of those available in a dataset,
            querying explicit information results in sparse matrices.
        </p>
        <p>
            Of course, sparse matrices are
            not sufficient for training a model, and it is unreasonable to expect a complete
            dataset of explicit data. So, we learn the similarities a given user has with other users,
            and use these to predict how much they would like some <i>unseen</i> item.
        </p>
        <p>
            While explicit feedback is preferable, it is also possible to use implicit feedback to reflect user
            behavior. Examples of implicit feedback include the browser history on a website, the number of
            clicks made on a given page, and a user's pattern of mouse movement. As opposed to explicit feedback,
            implicit feedback is represented by a densely filled matrix, because we (as researchers) can dictate how
            this data is to be collected or organized.
        </p>
        <p>
            Classical recommender systems can be grouped into two main approaches: content-based (CB) and
            collaborative filtering (CF).
            <!--The former one recommends an item, i.e. movie, song, ad, etc., to a user based on the item
            characteristics and user's interests. The latter one uses the known preferences of a group of users to make
            recommendations or predictions for other users.-->
        </p>

        <div>
            <div class="centered">
                <img src='CB.png' width="383px" height="470px">
            </div>
            <p>
                <b>Content-based filtering</b> generates a
                recommendation using additional information about the given user and item, through what we
                call <i>features</i>, which explain the observed interaction between a user and an item.
                <!-- Content-based methods are less prone to the <i>Cold-Start Problem</i> because new items or new
                users can be described using characteristics relating to them alone, rather than by describing them
                through their similarity to the behaviour of others'. -->
            </p>
            <figcaption id="left_caption_CB">
                On the left is an illustration of the content-based process. If Alan has watched one movie, the
                recommender system will then find similar movies to it, and Alan will be given a recommendation from the
                set of movies most similar to the one he has already watched.
            </figcaption>
        </div>

        <div>
            <div class="centered">
                <img src='CF.png' width="383px" height="408px">
            </div>
            <p>
                <b>Collaborative filtering:</b> generates a recommendation by relying on past user-item interaction,
                like explicit feedback (ratings) for movies watched in the past. In CF, it is sufficient to detect
                similar users and/or items, cluster them, and make new predictions based on the similarity existing
                within a cluster [6].
                <!-- The main issue with CF method is known as the <i>Cold-Start Problem</i>. -->

            </p>
            <figcaption id="left_caption_CF">
                On the left is an illustration of the collaborative filtering process. If Alan and Sarah have
                watched the same movies and have the same interests, the recommender system will learn this information
                and recommend to Sarah a movie that Alan has watched.
            </figcaption>
        </div>
        <p></p>

        <!-- User A will be
                recommended with a new item based on the interest of similar user B. Collaborative filtering methods
                belong to the bigger category of approaches called memory-based. that the predictions for a given user-item pair are made via dot
                product. So, if an item is not in the training dataset, the recommender system will not be able to query
                this item to generate a recommendation.  One of the most used
                methods, which is going to be decribed later, is called Matrix Factorization (MF).This issue is known as the cold-start problem. The main downside of this method is knwon as cold-start problem.-->

        <p></p>
        <p>
            The table below summarizes the advantages and disavantages of the two approaches. For more in-depth
            information, take a look at these references: [11, 12, 13].
        </p>
        <table>
            <tr>
                <th></th>
                <th>Content-based</th>
                <th>Collaborative Filtering</th>
            </tr>
            <tr>
                <th>Advantages</th>
                <td>
                    <ul>
                        <li>Does not require any data about the other users</li>
                        <li>Can recommend items which are relevant to the user, but not the population <br>(<i><q>niche
                                    items</q></i>)</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Does not require domain knowledge</li>
                        <li>Helps users discover new interests</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <th>Disadvantages</th>
                <td>
                    <ul>
                        <li>Requires a lot of domain knowledge</li>
                        <li>Makes recommendatios based only on the existing interests of the user <br>(no <i><q>niche
                                    items</q></i>)</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>cannot handle fresh items or users <br>(the <i><q>Cold-Start Problem</q></i>)</li>
                    </ul>
                </td>
            </tr>
        </table>

        <div>
            <h2>
                Matrix Factorization: Interpretable collaborative filtering
            </h2>

            <p></p>

            <p>
                Matrix Factorization (MF) is a class of collaborative filtering techniques [3]. In
                its most simplistic form, Matrix Factorization characterizes both the items and the users by a vector of
                factors (<i>matrices</i>), which then generate latent features (<i><q>embeddings</q></i>)
                when they are multiplied together (<i><q>into the matrix dot product</q></i>).
            </p>
            <p>
                This method has become popular because it offers flexibility for modeling real-life scenarios
                while maintaining robust scalability and predictive accuracy [2]. Moreover,
                since it is based on pure math, it can be classified as an <i>interpretable</i> recommendation method!
                With MF, we are able to track exactly how our input data is transformed by the model
                when making a recommendation.
            </p>
            <div class="example">
                <p class="example_text">
                    <i><b>This box is interactive!</b> Hover over the matrices below to learn how they are
                        used to calculate the dot product (and make a recommendation)</i>
                </p>

                <div class="row">
                    <div class="column-rmatrix-text">
                        <figcaption>Rating matrix</figcaption>
                    </div>
                    <div class="column-umatrix-text">
                        <figcaption>User matrix</figcaption>
                    </div>
                    <div class="column-imatrix-text">
                        <figcaption>Item matrix</figcaption>
                    </div>
                </div>
                <div class="row">
                    <div class="column">
                        <div id="parent5">
                            <img src="rating-matrix.png" width="300px">
                            <div id="popup5" style="display: None">The <b>rating matrix</b> stores the dot product of
                                the user and item matrices.</div>
                        </div>
                    </div>
                    <div class="column-umatrix">
                        <div id="parent6">
                            <img src="user-matrix.png" width="150px">
                            <div id="popup6" style="display: None">The <b>user matrix</b> stores the users' item-feature
                                preferences. Here, the 4 users set 2 feature preferences in a range of [0,1].
                                <!-- Usually the preference are in the range [0,1] where 0 means that the user
                                does not like that feature, while one means that the use like it. -->
                            </div>
                        </div>
                    </div>
                    <div class="column-imatrix">
                        <div id="parent7">
                            <img src="item-matrix.png" width="150px">
                            <div id="popup7" style="display: None">The <b>item matrix</b> stores the items' feature
                                scores. Here, each of the 4 items contains 2 features.
                            </div>
                        </div>
                    </div>
                </div>
                <!-- <div class="row">
                    <div class="column-rs-rmatrix">
                        <p>Rating Matrix</p>
                    </div>
                    <div class="column-rs-umatrix">
                        <p>User Matrix</p>
                    </div>
                    <div class="column-rs-imatrix">
                        <p>Item Matrix</p>
                    </div>
                </div> -->
            </div>

            <p></p>

            <p>
                Each item <i>i</i> and user <i>u</i> are associated with a vector <i>q<sub>i</sub></i> and
                <i>w<sub>u</sub></i>, respectively. For a given item, the corresponding vector measures the degree
                to which a feature represents the item. Similarly, the user vector <i>w<sub>u</sub></i>
                measures the degree of interest the user has in the item.
            </p>
            <p>The interaction, defined as <q>the interest of the user <i>u</i> in item <i>i</i></q> , is then captured
                by the dot product of these two vectors. Once all the dot products are computed, it becomes possible to
                rank the predicted ratings and identify the best item to recommend to any given user.
            </p>

            <div class="row">
                <div class="column">
                </div>
                <div class="column">
                    <img src="mf-formula.png" height="200px">
                </div>
                <div class="column">
                </div>
            </div>
            <div class="centered">
                <figcaption>Matrix Factorization formula.</figcaption>
            </div>

            <!-- <span class="katex-display">
                <span class="katex">
                    <span class="katex-mathmk">
                        <math>
                            <semantics>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mi>qui</mi>
                                    </msub>
                                    <mo>=</mo>
                                    <msup>
                                        <msub>
                                            <mi>q</mi>
                                            <mi>i</mi>
                                        </msub>
                                        <mi>T</mi>
                                    </msup>
                                    <mo>&#8901</mo>
                                    <msub>
                                        <mi>w</mi>
                                        <mi>u</mi>
                                    </msub>
                                    <mo>
                                        =
                                    </mo>
                                    <msub>
                                        <mo>&#8721;</mo>
                                        <mi>k</mi>
                                    </msub>
                                    <msub>
                                        <mi>p</mi>
                                        <mi>ik</mi>
                                    </msub>
                                    <mo>&#8901</mo>
                                    <msub>
                                        <mi>w</mi>
                                        <mi>ku</mi>
                                    </msub>
                                </mrow>
                            </semantics>
                        </math>
                    </span>
                </span>
            </span> -->

            <div class="example">
                <p></p>
                <p class="example_text">
                    <i><b>This box is interactive!</b> Adjust your preferences through the movie genre sliders
                        for comedy and horror, and then click on <q>Calculate Matrix Factorization</q> to see how
                        your preferences align with those of your friends'</i>
                </p>
                <p class="example_text">
                    Let's consider the following example: you are planning a movie night with your friends Anna,
                    Jonny, and Kimi. You know that Anna likes both horror movies and comedy, Jonny has a strong
                    preference for comedy, and Kimi prefers horror movies, but also enjoys comedy once in a while.
                    To find a movie that everyone will enjoy, you are going to use a recommender system
                    based on the Matrix Factorization techniques described above.
                </p>
                <div class="row">
                    <div class="column"></div>
                    <div class="column">
                        <p>Comedy preference:</p>
                        <input type="range" name="mySlider" id=comedySlider class="comedySlider" min="0.1" max="0.9"
                            step="0.1" value="0.5" , onchange="updateUserWeightComedy(this.value)">
                    </div>
                    <div class="column">
                        <p>Horror preference:</p>
                        <input type="range" name="mySlider" id=horrorSlider class="horrorSlider" min="0.1" max="0.9"
                            step="0.1" value="0.5" , onchange="updateUserWeightHorror(this.value)">
                    </div>
                </div>

                <table id="user_feature" class="user_table">
                    <tr>
                        <th>User</th>
                        <th>Comedy</th>
                        <th>Horror</th>
                    </tr>
                    <tr>
                        <td>Anna</td>
                        <td>0.6</td>
                        <td>0.5</td>
                    </tr>
                    <tr>
                        <td>Jonny</td>
                        <td>0.7</td>
                        <td>0.1</td>
                    </tr>
                    <tr>
                        <td>Kimi</td>
                        <td>0.4</td>
                        <td>0.9</td>
                    </tr>
                    <tr>
                        <td>You</td>
                        <td>0.5</td>
                        <td>0.5</td>
                    </tr>
                </table>

                <table id="item_feature" class="item_table">
                    <tr>
                        <th>Item</th>
                        <th>Comedy</th>
                        <th>Horror</th>
                    </tr>
                    <tr>
                        <td>Zombieland</td>
                        <td>3</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>Modern Times</td>
                        <td>5</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>The Grudge</td>
                        <td>1</td>
                        <td>5</td>
                    </tr>
                </table>

                <button id="MF_calculate" class="MF_button" type="button" onclick="calculateMatrixFact()">Calculate
                    Matrix Factorization</button>

                <p></p>

                <p class="example_text">
                    <i><b>How to read the results</b>: to help you decide which movie to watch, you just
                        look at the last row of the Matrix Factorization results. This row represents each movie's
                        average
                        predictive rating within your group.</i>
                </p>

                <table id="matrix_factorization" class="rec_table">
                    <!-- <tr>
                        <th>User</th>
                        <th>Zombieland</th>
                        <th>Modern Times</th>
                        <th>The Grudge</th>
                    </tr> -->
                </table>
            </div>

            <p></p>

            <p>
                While Matrix Factorization can produce good results in a short time, this method also
                features some disavantages:
            <ul>
                <li><b>Cold start problem</b>: The matrix cannot handle fresh items, such as new movies or new users
                    [14].
                </li>
                <li><b>Recommendation relevance</b>: Matrix Factorization uses the dot product to
                    recommend items. If all users have interacted and liked the same item, the recommendation will
                    focus on that item.</li>
                <li><b>Hard feature encoding</b>: In order to generate a recommendation, we have to explicitly
                    provide the system with user preferences and item features.</li>
            </ul>
            </p>

            <h2>Embedding powered systems</h2>
            <p>
                Nowadays, recommender systems consider many more features than our MF example above:
            </p>
            <ul>
                <li><b>Categorical</b>: userID, itemID, item brand, genre, language, etc.</li>
                <li><b>Numerical</b>: price, delivery time, number of reviews, average of the reviews, etc.</li>
                <li><b>Unstructured</b>: keywords, colors, material, review text, etc.</li>
            </ul>

            <p>In a real-world scenario, we likely would not have explicit data on the preferences of every user and the
                features of every item. This hinders our ability to make optimal recommendations. How might we
                resolve this?
            </p>

            <h3>EmbeddingMF: An embedding approach to matrix factorization</h3>
            <p>
                Building on top of our previous approach, Matrix Factorization, we learn the latent factors (implicit
                characteristics) for each movie and user, based on user-movie ratings. Learning these characteristics
                can be done through approached like gradient descent [16].
            </p>
            <p>
                We will use the <i><q>EmbeddingMF</q></i> approach, which includes a bias term on top of our existing
                dot product. We start by creating two embedding matrices:
            <ol>
                <li>
                    A user embedding matrix <i>U</i>, containing one user per row, and <i>n</i> user features as
                    columns.
                    <br>
                    <i>For a set of 100 users and 200 features, U will have dimensions of (100, 200)</i>
                </li>
                <li>
                    A movie embedding matrix <i>M</i>, containing one movie per row, and <i>n</i> movie features as
                    columns.
                    <br>
                    <i>For a set of 100 movies and 200 features, M will have dimensions of (100, 200)</i>
                </li>
            </ol>

            <p>
                Having the same number of columns in each matrix allows us to multiply the two embedding matrices
                (<i>U</i> x <i>M<sup>T</sup></i> ).
                Next, we add bias terms to each user and each movie. Adding bias to our matrix product results in
                a matrix representing predictive user ratings for all the movies in our dataset.
                Since these latent factors (features) are initialized by random numbers (independently and identically
                distributed Normal samples), the initial ratings that are
                computed by the model differ largely from the ground truth. During training, the difference
                between our latent factors and the ground truth is minimized.
            </p>
            <p>
                The model consists of a user matrix of size (n_users x 128) and a movie matrix of size (n_movies x
                128) and a user bias (n_users) and a movie bias (n_movies). We randomly initialize the latent factors
                for every user and movie with a mean of 0 and a standard deviation of 0.01. After the multiplication of
                users and movies we apply a sigmoid range that squeezes the results between 0 and 5.5 so the model can
                focus on learning something within this range. We trained the model over 15 epochs using the MSELoss, a
                learning rate of 0.005, and a weight decay of 0.1 which helps to prevent the model from overfitting.
            </p>
            <p style="color: red;">
                The EmbeddingFM was able to generate good recommendations with an average validation error of 0.71. The
                dataset, Movielens 1M, used to train and the model contains metadata as: the user occupation, user age,
                and location. How can use some or all of these metadatas?
            </p>
            <h3>DeepFM: A deep learning factorization machine</h3>
            <p>
                The adoption of deep learning models has been on the rise in every domain, including recommender
                system.
                The first model that generated state of the art (SOTA) results was Wide&Deep [5], a deep learning
                model made by Google in 2016. A complete timeline of SOTA model can be seen in the figure below. For the
                goal of this article, we are going to consider as a deep learning model, the Factorization-Machine based
                neural network (DeepFM), developed by Huawei in 2017 [6].
            </p>

            <!-- <h3>DeepFM</h3> -->
            <p>
                Architecturally, DeepFM consists of two components: a Factorization Machine (FM) component and a deep
                component that share the same input. For a feature <i>i</i>, a scale <i>w<sub>i</sub></i> is used to
                weigh its order-1 (linear) importance , a laten vector <i>V<sub>i</sub></i> is used to measure its
                impact of interactions with other features. The laten vector is then fed in the FM component to model
                order-2 (pairwise) feature interactions.
                The result, <i>y<sub>FM</sub></i> , is then fed in the deep component to model the high-order
                feature interactions.
                All parameters are trained joyintly for the combined prediction <i>y</i> represented by the
                following formula:
            </p>
            <div class="row">
                <div class="column">
                </div>
                <div class="column">
                    <img src="deepfm-formula.png" height="170px">
                </div>
                <div class="column">
                </div>
            </div>
            <figcaption class="centered">DeepFM output formula.</figcaption>
            <p></p>
            <p>
                <b>Factorization Machines</b>: Are model class that combines the advantages of Support Vector
                Machines (SVM) with factorization models [7]. Factorization Machine are are a general predictor that
                model all interactions between variables using factorized parameters. By doing so, they are able to
                estimate interactions even in problems with huge sparsisty as is the case in recommender systems.
            </p>

            <p>
                <b>Deep component</b>: The deep component is a feed-forward neural network which is used to learn
                high-order feature interactions. Two interesting feature of this deep learning structure are:
            <ol>
                <li>While the lengths of different input field vectors can be different, thei embedding are of the
                    same size.</li>
                <li>The latent feature vectors, output of the FM, is now use as network weights which are learned
                    and used to compress the input fields vector to the embedding vectors. </li>
            </ol>
            </p>

            <h2>One recommender cannot rule them all</h2>
            <div class="quote">
                <h3>
                    <blockquote><q>All models are wrong, but some are useful.</q> [15] </br>
                        <h6>- George Box, 1976</h6>
                    </blockquote>

                </h3>
            </div>

            <p>
                We have trained the two models described above, the EmbeddingFM and the DeepFM, with the task of
                generating a recommendation to a test set of 100k entries. By plotting the distribution of the true and
                predictive rating, see figure below, it is possible to notice that the distribution of the DeepFM is
                skewed towards the rating 3, while the one of the EmbeddingFM is skewed towards the 4 as the true
                ratings.

                [TODO: add mean ratings of all models in this and error plot]
            </p>
            <div class="example">
                <div id="tester2" style="width:750px;height:700px;"></div>
            </div>
            <figcaption class="centered">TODO</figcaption>
            <p></p>
            <p>
                To better understand these results, we decide to validate our approaches using the Root Mean Squared
                Error (RMSE), one of the most used metrics in the Recommender System field. RMSE is typically used when
                the developer wants to evaluate a predicted score, like the predictive rating of a movie, and compare it
                to a ground truth (true rating). Compared to other metrics, RMSE but more emphasis on larger absolute
                error. Lower RMSE better translate in a better recommendation accuracy [1, 8].
            </p>
            <div class="row">
                <div class="column">
                </div>
                <div class="column">
                    <img src="rmse-formula.png" height="170px">
                </div>
                <div class="column">
                </div>
            </div>

            <p>
                By plotting the RMSE of the two models it is possible to notice that both the two models described
                above present a high RMSE value at the two extremes (prediction rating of 1 or 2 and rating of 5). While
                the error on rating 1 and 2 can be explained considering that <q>people are more willing to share
                    positive experiences than negative ones</q> [9].
            </p>
            <div class="example">
                <div id="tester" style="width:750px;height:700px;"></div>
            </div>
            <figcaption>TODO</figcaption>
            <p></p>
            <p>
                We define a perfect recommendation systems as system that will recommend only movies that the
                user will 100% like and rate as 5. The above plot, on the contrary, it shows that both models are
                not perfect in recommending that kind of movies. Based on this evidence and our definition of perfect
                recommender system, we decide to use the explain by example methodology to explain how the two
                models generate the movie recommendations for a user that are predicted with a rating of 5.
            </p>
            <p>
                To support this direction, we are going to use a custom Venn Diagram with three sets: true rating
                (movie rated 5 by the users), predicted ratings from the embedding matrix factorization, and predicted
                ratings from the DeepFM model.
            </p>
            <p style="color: red;">
                WRITE SOMETHING HERE
            </p>
            <div class="row">
                <div class="centered">
                    <img src="how-to-venn.png" height="600px">
                </div>
            </div>
            <figcaption class="centered">
                Description of the different areas of the Venn Diagram.
            </figcaption>

            <p></p>
            <div class="example">
                <p class="example_text" style="color: red;">
                    Let's consider the following user: Xiao. He is 25-34 years old writer who lives in the West Coast.
                    We have retrieved the top 10ish movies that both models would recommend to himand some movies that
                    he liked and rate 5 but the models have not recommended to him.
                </p>
                <p class="example_text">
                    <i><b>This box is interactive!</b> the movies are represented by dot in the different sets of the
                        Venn Diagram. The line that starts from the center represent the error that has been made.</i>
                </p>
                <div class="row">
                    <div class="column example_text">
                        <p class="example_text"><b>EmbeddingFM</b></p>
                    </div>
                    <div class="column">
                        <p class="example_text"><b>DeepFM</b></p>
                    </div>
                    <div class="column">
                    </div>
                </div>
                <div class="row">
                    <div class="column example_text">
                        <img src="embeddingfm-error1.png" width="100px">
                    </div>
                    <div class="column example_text">
                        <img src="deepfm-error1.png" width="100px">
                    </div>
                    <div class="column-text">
                        <p>The model under estimate the rating that the user will give.</p>
                    </div>
                </div>
                <div class="row">
                    <div class="column example_text">
                        <img src="embeddingfm-error2.png" width="100px">
                    </div>
                    <div class="column example_text">
                        <img src="deepfm-error2.png" width="100px">
                    </div>
                    <div class="column-text">
                        <p>The model over estimate the rating that the user will give.</p>
                    </div>
                </div>
                <p></p>
                <p class="example_text">
                    <i>Hover one of the point to discover what is the movie name, the
                        true rating, and the predicted scores from the model(s)</i>
                </p>
                <div id='myDiv'></div>
            </div>
            <p></p>
            <p>
                Of the above plot, what it is interesting to notice are the two movie in the bottom left of the true
                rating set and the two movies in the intersection between the two movies. The first movies represent
                movies that the user has liked and rate 5 but both models will not recommend to the user. The latter
                ones, are movies that both models think that the user will like and rate 5 but in reality the users will
                not like.
            </p>
            <p>
                We can explore more in details these cases where the movies recommended and the user preferences do
                not overlap, we can plot the rating distribution on the training data together with the user rating. By
                doing so, we can see if the model suffer from some kind of bias or not.
            </p>
            <div id="ratings1" style="width:750px;height:350px;"></div>
            <figcaption class="centered">
                Dashed lines in <b>brown (DeepFM)</b> and <b>yellow (EmbeddingMF)</b> reflect the prediction of each
                model for <b>User 1680</b>
            </figcaption>
            <br />
            <div id="ratings2" style="width:750px;height:350px;"></div>


            <h2>Conclusion</h2>
            <p style="color: red;">TO EDIT : the two models above actually result in
                non-personalized recommendations, such as those you may have seen in print newspapers or
                magazines. These recommendations rely solely on popular opinion of the population,
                rather than characteristics specific to a user.
            </p>
            <p>
                While recommender systems aims in generating a personalized experience on the web, the model are not
                trained on a single user but on a group. With this article we have shows that ....
                Thanks to this explnation we tried to show that if the focus shift from data/model centric to more
                human centric the models are not really generate personalized recommendations.
            </p>
    </d-article>

    <d-appendix>
        <h3>Acknowledgments</h3>
        <p>Text</p>
        <h3>Further Reading</h3>
        <p>text</p>
        <h3>References</h3>
        <p>
            [1] Ricci, Francesco, Lior Rokach, and Bracha Shapira. "Introduction to recommender systems handbook."
            Recommender systems handbook. Springer, Boston, MA, 2011. 1-35.
        </p>
        <p>
            [2] Koren, Yehuda, Robert Bell, and Chris Volinsky. "Matrix factorization techniques for recommender
            systems." Computer 42.8 (2009): 30-37.
        </p>
        <p>
            [3] Lee, Daniel D., and H. Sebastian Seung. "Learning the parts of objects by non-negative matrix
            factorization." Nature 401.6755 (1999): 788-791.
        </p>
        <p>
            [4] Glauber, Rafael, and Angelo Loula. "Collaborative filtering vs. content-based filtering: differences and
            similarities." arXiv preprint arXiv:1912.08932 (2019).
        </p>
        <p>
            [5] Cheng, Heng-Tze, et al. "Wide & deep learning for recommender systems." Proceedings of the 1st workshop
            on deep learning for recommender systems. 2016.
        </p>
        <p>
            [6] Guo, Huifeng, et al. "DeepFM: a factorization-machine based neural network for CTR prediction." arXiv
            preprint arXiv:1703.04247 (2017).
        </p>
        <p>
            [7] Rendle, Steffen. "Factorization machines." 2010 IEEE International conference on data mining. IEEE,
            2010.
        </p>
        <p>
            [8] Isinkaye, Folasade Olubusola, Yetunde O. Folajimi, and Bolande Adefowoke Ojokoh. "Recommendation
            systems: Principles, methods and evaluation." Egyptian informatics journal 16.3 (2015): 261-273.
        </p>
        <p>
            [9] 2018 Customer Experience, https://www.sitel.com/report/2018-cx-index/
        </p>
        <p>
            [10] Deisenroth, Marc Peter, A. Aldo Faisal, and Cheng Soon Ong. Mathematics for machine learning. Cambridge
            University Press, 2020.
        </p>
        <p>
            [11] Pazzani, Michael J., and Daniel Billsus. "Content-based recommendation systems." The adaptive web.
            Springer, Berlin, Heidelberg, 2007. 325-341.
        </p>
        <p>
            [12] Sharma, Ritu, Dinesh Gopalani, and Yogesh Meena. "Collaborative filtering-based recommender system:
            Approaches and research challenges." 2017 3rd international conference on computational intelligence &
            communication technology (CICT). IEEE, 2017.
        </p>
        <p>
            [13] Hannon, John, Mike Bennett, and Barry Smyth. "Recommending twitter users to follow using content and
            collaborative filtering approaches." Proceedings of the fourth ACM conference on Recommender systems. 2010.
        </p>
        <p>
            [14] Lika, Blerina, Kostas Kolomvatsos, and Stathes Hadjiefthymiades. "Facing the cold start problem in
            recommender systems." Expert systems with applications 41.4 (2014): 2065-2073.
        </p>
        <p>
            [15] Box, George E. P. (1976), "Science and statistics" (PDF), Journal of the American Statistical
            Association, 71 (356): 791-799, doi:10.1080/01621459.1976.10480949.
        </p>
        <p>
            [16] Ruder, Sebastian. "An overview of gradient descent optimization algorithms." arXiv preprint
            arXiv:1609.04747 (2016).
        </p>
        <h3>Reuse</h3>
        <p>
            Diagrams and text are licensed under Creative Commons Attribution CC-BY 4.0 with the source available on
            GitHub, unless noted otherwise. The figures that have been reused from other sources don’t fall under this
            license and can be recognized by a note in their caption: “Figure from …”.
        </p>

    </d-appendix>

    <script>

        var e = document.getElementById('parent');
        e.onmouseover = function () {
            document.getElementById('popup').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup').style.display = 'none';
        }

        var e = document.getElementById('parent2');
        e.onmouseover = function () {
            document.getElementById('popup2').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup2').style.display = 'none';
        }

        var e = document.getElementById('parent3');
        e.onmouseover = function () {
            document.getElementById('popup3').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup3').style.display = 'none';
        }

        var e = document.getElementById('parent4');
        e.onmouseover = function () {
            document.getElementById('popup4').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup4').style.display = 'none';
        }

        var e = document.getElementById('parent5');
        e.onmouseover = function () {
            document.getElementById('popup5').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup5').style.display = 'none';
        }

        var e = document.getElementById('parent6');
        e.onmouseover = function () {
            document.getElementById('popup6').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup6').style.display = 'none';
        }

        var e = document.getElementById('parent7');
        e.onmouseover = function () {
            document.getElementById('popup7').style.display = 'block';
        }
        e.onmouseout = function () {
            document.getElementById('popup7').style.display = 'none';
        }

        function updateUserWeightComedy(slideAmount) {
            //  to retrieve the value of the slider and display it
            //	var sliderDiv = document.getElementById("sliderAmount");
            //  sliderDiv.innerHTML = slideAmount;

            var cell_change = document.getElementById("user_feature").rows[4].cells;
            // console.log(cell_change)
            cell_change[1].innerHTML = slideAmount;
            // to save the new array
            CacheValues();
        }

        function updateUserWeightHorror(slideAmount) {
            //  to retrieve the value of the slider and display it
            //	var sliderDiv = document.getElementById("sliderAmount");
            //  sliderDiv.innerHTML = slideAmount;

            var cell_change = document.getElementById("user_feature").rows[4].cells;
            // console.log(cell_change)
            cell_change[2].innerHTML = slideAmount;
            // to save the new array
            CacheValues();
        }

        function createGroups(arr, numGroups) {
            const perGroup = Math.ceil(arr.length / numGroups);
            return new Array(numGroups)
                .fill('')
                .map((_, i) => arr.slice(i * perGroup, (i + 1) * perGroup));
        }

        // create an empty array to store the values
        var matrix_user = [];
        var matrix_score = [];

        function CacheValues() {

            matrix_user = [];
            matrix_score = [];

            // retrieve all the code of the table
            var user_table = document.getElementById("user_feature");
            var score_table = document.getElementById("item_feature");

            // get length of the rows
            var row_length = user_table.rows.length;
            var score_row_length = score_table.rows.length;

            for (let i = 1; i < row_length; i++) {
                // retrieve cells info
                var table_cells = user_table.rows.item(i).cells;

                // gets amount of cells of current row
                var col_length = table_cells.length;

                for (var j = 0; j < col_length; j++) {
                    // get cell info here 
                    var cell_value = table_cells.item(j).innerHTML;
                    // console.log(cell_value)
                    // push every row value in the empty matrix
                    matrix_user.push(cell_value);
                }
            }

            for (let i = 1; i < score_row_length; i++) {
                // retrieve cells info
                var score_table_cells = score_table.rows.item(i).cells;

                // gets amount of cells of current row
                var score_col_length = score_table_cells.length;

                for (var j = 0; j < score_col_length; j++) {
                    // get cell info here 
                    var score_cell_value = score_table_cells.item(j).innerHTML;
                    matrix_score.push(score_cell_value);
                }
            }
            return {
                mu: matrix_user,
                ms: matrix_score
            }
        }

        function calculateMatrixFact() {

            var cache = CacheValues();

            // split the matrix into arrays one for each user and movie
            var user_matrix = createGroups(cache.mu, 4);
            // console.log(user_matrix);
            var score_matrix = createGroups(cache.ms, 3);
            //console.log(score_matrix);

            // remove the string user_name and movie_name
            for (let i = 0; i < user_matrix.length; i++) {
                user_matrix[i].shift();
            }

            for (let j = 0; j < score_matrix.length; j++) {
                score_matrix[j].shift();
            }

            var dot_matrix = [];
            var scores = [];
            var average_one = [];
            var average_two = [];
            var average_three = [];

            // perform the dot product
            for (let j = 0; j < user_matrix.length; j++) {
                for (let k = 0; k < score_matrix.length; k++) {
                    //console.log(user_matrix[j])
                    //console.log(score_matrix[k])
                    var dot_product = (math.multiply(user_matrix[j], score_matrix[k])).toFixed(1);
                    //console.log(dot_product)
                    dot_matrix.push(dot_product);
                }
            }

            for (let i = 0; i < dot_matrix.length; i++) {
                scores.push(dot_matrix[i])
            }
            for (let j = 0; j < scores.length; j += 3) {
                average_one.push(scores[j]);
            }
            for (let j = 1; j < scores.length; j += 3) {
                average_two.push(scores[j]);
            }
            for (let j = 2; j < scores.length; j += 3) {
                average_three.push(scores[j]);
            }
            var avg_one = math.mean(average_one).toFixed(1);
            var avg_two = math.mean(average_two).toFixed(1);
            var avg_three = math.mean(average_three).toFixed(1);

            dot_matrix.push(avg_one, avg_two, avg_three)

            // create the matrix and push back the string (first column of the table)
            var dot_prod_matrix = createGroups(dot_matrix, 5);
            dot_prod_matrix[0].unshift("Anna");
            dot_prod_matrix[1].unshift("Jonny");
            dot_prod_matrix[2].unshift("Kimi");
            dot_prod_matrix[3].unshift("You");
            dot_prod_matrix[4].unshift("Average")

            // from array to HTML table
            fetch = document.getElementById('matrix_factorization');
            fetch.innerHTML = `<tr>
            <th>User</th>
            <th>Zombieland</th>
            <th>Modern Times</th>
            <th>The Grudge</th>
             </tr>`;

            for (var i = 0; i < dot_prod_matrix.length; i++) {
                var newRow = fetch.insertRow(fetch.length);
                for (var j = 0; j < dot_prod_matrix[i].length; j++) {
                    var cell = newRow.insertCell(j);
                    cell.innerHTML = dot_prod_matrix[i][j];
                }
            }

        }

        TESTER = document.getElementById('tester');
        TESTER2 = document.getElementById('tester2');
        PREDICTIONS1 = document.getElementById('ratings1');
        PREDICTIONS2 = document.getElementById('ratings2');

        function unpack(row, key) {
            return row.map(function (row) { return row[key] });
        }


        // Error plot //
        var drawChartError = async () => {

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/nn_rmse_df.csv",
                function (rows) {
                    return {
                        rmse: rows.rmse,
                        rating: rows.rating
                    }
                }).then(
                    function (rows) {

                        var x = unpack(rows, 'rating')
                        var y = unpack(rows, 'rmse')

                        console.log(x)
                        console.log(y)
                        var errors_nn = {
                            name: 'EmbeddingMF',
                            x: x,
                            y: y,
                            type: "scatter",
                            mode: "lines+markers",
                            line: { shape: 'spline' },
                            fill: 'tozeroy',
                            fillcolor: 'rgba(57, 45, 50, 0.3)',
                            marker: { color: "#392d32" },
                            hovertemplate: '<b>RMSE: %{y:.2f}</b>' +
                                '<br>True Rating: %{x}<br>'
                        };
                        var layout = {
                            title: {
                                text: "Distribution of Root Mean Squared Errors: <br><i>EmbeddingMF vs. DeepFM</i>",
                                font: {
                                    size: 20
                                },
                                xref: 'paper',
                                x: 0.01,

                            },
                            xaxis: {
                                title: "<b>True Rating (Categorical)<b>"
                            },
                            yaxis: {
                                title: "<b>RMSE</b>"
                            },
                            plot_bgcolor: "rgba(0,0,0,0)",
                            paper_bgcolor: "rgba(0,0,0,0)",
                            showlegend: true,
                            legend: {
                                "orientation": "h",
                                x: 1,
                                xanchor: 'right',
                                y: 1
                            }

                        };
                        var config = { responsive: true, displayModeBar: false };

                        if (document.getElementById("tester")) {
                            Plotly.newPlot(TESTER, [errors_nn], layout, config)

                        }

                    }
                )

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/deepfm_rmse_df.csv",
                function (rows) {
                    return {
                        rmse: rows.rmse

                    }
                }).then(
                    function (rows) {
                        var y = unpack(rows, 'rmse')
                        //https://coolors.co/211a1d-f4c3c2-f49f0a-c7f0bd-81adc8

                        console.log(y)
                        var errors_deepfm = {
                            name: 'DeepFM',
                            x: [1, 2, 3, 4, 5],
                            y: y,
                            type: "scatter",
                            mode: "lines+markers",
                            line: { shape: 'spline' },
                            fill: 'tozeroy',
                            fillcolor: 'rgba(244, 159, 10, 0.6)',
                            marker: { color: "#F49F0A" },
                            hovertemplate: '<b>RMSE: %{y:.2f}</b>' +
                                '<br>True Rating: %{x}<br>'

                        };

                        var config = { responsive: true };

                        if (document.getElementById("tester")) {
                            Plotly.addTraces(TESTER, errors_deepfm, 0)

                        }

                    }
                )

        }
        if (document.getElementById('tester')) {
            drawChartError();
        }


        // Density Plot //
        var drawChartDensity = async () => {

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/ratings_val.csv",
                function (rows) {
                    return {
                        true_rating: rows.true_rating,
                        pred_rating: rows.pred_rating
                    }
                }).then(
                    function (rows) {

                        var y1 = unpack(rows, 'true_rating')
                        var y2 = unpack(rows, 'pred_rating')
                        //https://coolors.co/211a1d-f4c3c2-f49f0a-c7f0bd-81adc8

                        console.log(y1)
                        console.log(y2)
                        var true_ratings = {
                            name: 'True Rating',
                            x: y1,
                            type: "histogram",
                            histnorm: "density",
                            //alignmentgroup: "1",
                            //ybins:{
                            //    end: 5,
                            //    start: 1,
                            //    size:5
                            //},
                            marker: { color: "rgba(103, 141, 88, 0.5)" },
                            hoverlabel: {
                                namelength: 15
                            },
                        };
                        var embeddings_ratings = {
                            name: 'EmbeddingMF (Predicted Rating)',
                            x: y2,
                            type: "histogram",
                            histnorm: "density",
                            //alignmentgroup: "1",
                            //ybins:{
                            //    end: 5,
                            //    start: 1,
                            //    
                            //},
                            marker: { color: "#392d32" },

                        };
                        var layout = {
                            title: {
                                text: "Distribution of Ratings by Model: <br><i>True vs. EmbeddingMF vs. DeepFM</i>",
                                font: {
                                    size: 20
                                },
                                xref: 'paper',
                                x: 0.01,

                            },
                            xaxis: {
                                title: "<b>True Rating (Categorical (true) and Numeric (predictions))<b>"
                            },
                            yaxis: {
                                title: "<b>Count</b>"
                            },
                            plot_bgcolor: "rgba(0,0,0,0)",
                            paper_bgcolor: "rgba(0,0,0,0)",
                            showlegend: true,
                            legend: {
                                "orientation": "h",
                                x: 1,
                                xanchor: 'right',
                                y: 1
                            },
                            barmode: "overlay"

                        };
                        var config = { responsive: true, displayModeBar: false };

                        if (document.getElementById("tester2")) {
                            Plotly.newPlot(TESTER2, [embeddings_ratings, true_ratings], layout, config)

                        }

                    }
                )

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/deepFM-final-dataset.csv",
                function (rows) {
                    return {
                        pred_rating: rows.pred_rating

                    }
                }).then(
                    function (rows) {
                        var x = unpack(rows, 'pred_rating')

                        console.log(x)
                        var deepfm_ratings = {
                            name: 'DeepFM (Predicted Rating)',
                            x: x,
                            type: "histogram",
                            histnorm: "density",
                            //alignmentgroup: "1",
                            //ybins:{
                            //    end: 5,
                            //    start: 1,
                            //   
                            //},
                            marker: { color: 'rgba(244, 159, 10, 0.6)' },

                        };

                        if (document.getElementById("tester2")) {
                            Plotly.addTraces(TESTER2, deepfm_ratings, 2)

                        }

                    }
                )

        }
        if (document.getElementById('tester2')) {
            drawChartDensity();
        }


        //TODO: Fix labels on layout1, and the user ratings square on layout 2 (to user rating = 5)
        // Training Ratings Dist plot
        var drawRatingDensity = async () => {
            // User highlight: rgba(142, 181, 205, 0.4)
            // Mean vertical marker: "#C97064"

            var config = { responsive: true, displayModeBar: false };
            var layout1 = {
                title: {
                    text: "<i>Buffy the Vampire Slayer</i>: Distribution of Training Set Ratings",
                    font: {
                        size: 20
                    },
                    xref: 'paper',
                    x: 0.01,

                },

                yaxis: {
                    title: "<b>True Rating</b>"
                },
                showlegend: false,
                legend: {
                    "orientation": "h",
                    x: 1,
                    xanchor: 'right',
                    y: 1
                },
                shapes: [
                    // 3264: Buffy the Vampire Slayer
                    // mean: 2.79, 'rgba(103, 141, 88, 0.6)',
                    // user_rating = 1
                    // model_deepfm_rating = 4.53, 'rgba(57, 45, 50, 0.6)',
                    // model_embeddingMF_rating = 3.8,  'rgba(244, 159, 10, 0.6)',

                    {
                        type: 'rect',
                        x0: 0.5,
                        y0: 0,
                        x1: 1.5,
                        y1: 34.1,
                        line: {
                            color: 'rgba(142, 181, 205, 1)',
                            width: 3
                        }
                    },
                    {   //training
                        type: 'line',
                        x0: 2.79,
                        y0: 0,
                        x1: 2.79,
                        y1: 185,
                        line: {
                            color: 'rgba(103, 141, 88, 0.6)',
                            width: 2,
                            dash: 'dashdot'
                        }
                    },
                    {   //DeepFM
                        type: 'line',
                        x0: 4.53,
                        y0: 0,
                        x1: 4.53,
                        y1: 185,
                        line: {
                            color: 'rgba(57, 45, 50, 0.6)',
                            width: 2,
                            dash: 'dashdot'
                        }
                    },
                    {   //EmbeddingMF
                        type: 'line',
                        x0: 3.8,
                        y0: 0,
                        x1: 3.8,
                        y1: 185,
                        line: {
                            color: 'rgba(244, 159, 10, 0.6)',
                            width: 2,
                            dash: 'dashdot'
                        }
                    },
                ],
                annotations: [
                    {
                        showarrow: false,
                        text: "<b>User Rating: 1</b>",
                        x: 1,
                        xanchor: "center",
                        y: 45,
                        font: {
                            color: 'rgba(142, 181, 205, 0.8)',
                        }
                    },
                    {
                        showarrow: false,
                        text: "<b>2.79</b><br>Training<br>Mean",
                        x: 2.8,
                        xanchor: "left",
                        y: 114,
                        yanchor: "bottom",
                        align: "left",
                        font: {
                            color: 'rgba(103, 141, 88, 0.8)',
                        }
                    },
                    {//EmbeddingMF
                        showarrow: false,
                        text: "<b>3.8</b>",
                        x: 3.79,
                        xanchor: "right",
                        y: 160,
                        yanchor: "right",
                        font: {
                            color: 'rgba(244, 159, 10, 0.6)',
                        }
                    },
                    {//DeepFM
                        showarrow: false,
                        text: "<b>4.53</b>",
                        x: 4.52,
                        xanchor: "right",
                        y: 160,
                        yanchor: "right",
                        font: {
                            color: 'rgba(57, 45, 50, 0.6)',
                        }
                    }

                ],
            }
            var layout2 = {

                title: {
                    text: "<i>Who's That Girl?</i>  Distribution of Training Set Ratings",
                    font: {
                        size: 20
                    },
                    xref: 'paper',
                    x: 0.01,

                },

                yaxis: {
                    title: "<b>True Rating</b>"
                },
                showlegend: false,
                legend: {
                    "orientation": "h",
                    x: 1,
                    xanchor: 'right',
                    y: 1
                },

                shapes: [
                    // 3391: Who's That Girl?
                    // mean: 2.66
                    // model_deepfm_rating = 2.06
                    // model_embeddingMF_rating = 2.40

                    {
                        type: 'rect',
                        name: "user rating",
                        x0: 4.5,
                        y0: 0,
                        x1: 5.5,
                        y1: 1.05,
                        line: {
                            color: 'rgba(142, 181, 205, 0.6)',
                            width: 4
                        }
                    },
                    {
                        type: 'line',
                        x0: 2.66,
                        y0: 0,
                        x1: 2.66,
                        y1: 40,
                        line: {
                            color: 'rgba(103, 141, 88, 0.6)',
                            width: 2,
                            dash: 'dashdot'
                        }
                    },

                    {   //EmbeddingMF
                        type: 'line',
                        x0: 2.06,
                        y0: 0,
                        x1: 2.06,
                        y1: 40,
                        line: {
                            color: 'rgba(57, 45, 50, 0.6)',
                            width: 2,
                            dash: 'dashdot'
                        }
                    },
                    {   //DeepFM
                        type: 'line',
                        x0: 2.40,
                        y0: 0,
                        x1: 2.40,
                        y1: 40,
                        line: {
                            color: 'rgba(244, 159, 10, 0.6)',
                            width: 2,
                            dash: 'dashdot'
                        }
                    },

                ],
                annotations: [
                    {
                        showarrow: false,
                        text: "<b>User Rating: 5</b>",
                        x: 5,
                        xanchor: "center",
                        y: 3.5,
                        font: {
                            color: 'rgba(142, 181, 205, 0.8)',


                        }
                    },
                    {
                        showarrow: false,
                        text: "<b>2.66</b><br>Training<br>Mean",
                        x: 2.7,
                        xanchor: "left",
                        y: 38,
                        yanchor: "top",
                        align: "left",
                        font: {
                            color: 'rgba(103, 141, 88, 0.6)',
                        }
                    },
                    {//EmbeddingMF
                        showarrow: false,
                        text: "<b>2.06</b>",
                        x: 2.05,
                        xanchor: "right",
                        y: 36,
                        yanchor: "right",
                        font: {
                            color: 'rgba(57, 45, 50, 0.6)',
                        }
                    },
                    {//DeepFM
                        showarrow: false,
                        text: "<b>2.4</b>",
                        x: 2.39,
                        xanchor: "right",
                        y: 36,
                        yanchor: "right",
                        font: {
                            color: 'rgba(244, 159, 10, 0.6)',
                        }
                    }
                ],
            }

            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/user-hate-model-loved.csv",

                // 3264: Buffy the Vampire Slayer
                // mean: 2.79
                // user_rating = 1
                // model_deepfm_rating = 4.53
                // model_embeddingMF_rating = 3.8

                function (rows) {
                    return {
                        rating: rows.rating
                    }
                }).then(
                    function (rows) {
                        var ratings = unpack(rows, 'rating')
                        console.log(ratings)

                        var movie_ratings_userhate = {
                            name: 'Buffy the Vampire Slayer',
                            x: ratings,
                            type: "histogram",
                            histnorm: "count",
                            marker: { color: 'rgba(103, 141, 88, 0.4)' },

                        };
                        if (document.getElementById("ratings1")) {
                            Plotly.newPlot(PREDICTIONS1, [movie_ratings_userhate], layout1, config)

                        }
                    }
                )

            // 3391: Who's That Girl?
            await d3.csv("https://raw.githubusercontent.com/ibrahimalhazwani/distill-xai/main/user-loved-model-hate.csv",

                // 3391: Who's That Girl?
                // mean: 2.66
                // model_deepfm_rating = 2.06
                // model_embeddingMF_rating = 2.40

                function (rows) {
                    return {
                        rating: rows.rating
                    }
                }).then(
                    function (rows) {
                        var ratings = unpack(rows, 'rating')
                        console.log(ratings)

                        var movie_ratings_userlove = {
                            name: 'Who\'s That Girl?',
                            x: ratings,
                            type: "histogram",
                            histnorm: "count",
                            marker: { color: 'rgba(103, 141, 88, 0.4)' },
                        };
                        if (document.getElementById("ratings2")) {
                            Plotly.newPlot(PREDICTIONS2, [movie_ratings_userlove], layout2, config)

                        }

                    }

                )
        }

        if (document.getElementById('ratings1') && (document.getElementById('ratings2'))) {
            drawRatingDensity();
        }

        // venn diagram
        function map_to_range(number, in_min, in_max, out_min, out_max) {
            return (((number - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min);
        }

        var in_min = -2
        var in_max = 2
        var out_min = -0.25
        var out_max = 0.25

        // trace for movies that the user likes
        var trace1 = {
            x: [0.6, 0.7, 0.8],
            y: [0.7, 1.4, 0.4],
            error: [1.58, 2.60, 0.71],
            errorIbra: [0.94, 2.93, 1.11],
            type: 'scatter',
            mode: 'markers',
            // text: [['Return to Oz', "Who's That Girl?", 'Crimes and Misdemeanors'], [4.1, 2.1, 3.9], [3.4, 2.4, 4.3]],
            text: [['Return to Oz', 4.1, 3.4], ["Who's That Girl?", 2.1, 2.4], ['Crimes and Misdemeanors', 3.9, 4.3]],
            deepFM_pred: [4.1, 2.1, 3.9],
            embMF_pred: [3.4, 2.4, 4.3],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 5,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'DeepFM predicted rating: %{text[1]}<br>' +
                'EmbeddingMF predicted rating: %{text[2]}'
        };

        // trace for movie that the EmbeddingFM recommend and user liked
        var trace2 = {
            x: [1.2, 1.5,],
            y: [0.5, 0.7],
            type: 'scatter',
            mode: 'markers',
            text: [['Pulp Fiction', 5, 4.6], [' Stand by Me', 5, 4.3]],
            error: [0.4, 0.7],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'True rating: %{text[1]}<br>' +
                'EmbeddingMF predicted rating: %{text[2]}'

        };
        // trace for movies that the EmbeddingFM recommend (no overlap)
        var trace3 = {
            x: [2, 2.5],
            y: [0.2, 0.55],
            type: 'scatter',
            mode: 'markers',
            text: [['Network', 4.56, 4], ['Bonnie and Clyde', 4.54, 3]],
            error: [-0.56, -1.54],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'True rating: %{text[2]}<br>' +
                'EmbeddingMF predicted rating: %{text[1]}'

        };
        // trace for movies that DeepFM has recommended no overlap
        var trace4 = {
            x: [2, 2.2, 2.6],
            y: [2, 2.5, 2.2],
            type: 'scatter',
            mode: 'markers',
            text: [['Kingpin', 4, 4.63], ['Siren', 4, 4.85], ['Body Heat', 4, 4.61]],
            error: [-0.63, -0.85, -0.61],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'True rating: %{text[1]}<br>' +
                'DeepFM predicted rating: %{text[2]}'

        };
        // trace for movies that both systems have recommended but the user do not like
        var trace5 = {
            x: [2.2],
            y: [1.2],
            type: 'scatter',
            mode: 'markers',
            text: [['Buffy the Vampire Slayer', 1, 4.54, 3.8]],
            error: [-2.80],
            errorIbra: [-3.54],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'True rating: %{text[1]}<br>' +
                'DeepFM predicted rating: %{text[2]}<br>' +
                'EmbeddingMF predicted rating: %{text[3]}'

        };
        // trace for movies that both recommender have recommended and the user has liked
        var trace6 = {
            x: [1.7],
            y: [1.3],
            type: 'scatter',
            mode: 'markers',
            text: [['Frankenstein', 5, 4.79, 3.36]],
            error: [0.64],
            errorIbra: [0.21],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'True rating: %{text[1]}<br>' +
                'DeepFM predicted rating: %{text[2]}<br>' +
                'EmbeddingMF predicted rating: %{text[3]}'
        };
        //movie that deepFM recommend and user likes
        var trace7 = {
            x: [1.5, 1.23, 1.69, 1.4],
            y: [1.5, 1.7, 1.54, 1.4],
            type: 'scatter',
            mode: 'markers',
            text: [['Delicatessen', 5, 4.58], ['Watership Down', 5, 4.54], ['Clueless', 5, 4.54], ["The Decline of Western Civilization", 5, 4.7]],
            error: [0.41, 0.45, 0.46, 0.29],
            textfont: {
                color: ['red', 'orange', 'green'],
                size: 12,
                family: 'Arial'
            },
            marker: {
                color: 'black',
                size: 3,
                line: {
                    color: 'black',
                    width: 1
                }
            },
            hovertemplate: '<b>Movie title: %{text[0]}</b><br><br>' +
                'True rating: %{text[1]}<br>' +
                'DeepFM predicted rating: %{text[2]}'
        };

        var layout = {
            title: 'True & Predicted Ratings for User 1680',
            annotations: [
                {
                    x: 0.4,
                    y: 1.8,
                    xref: 'x',
                    yref: 'y',
                    text: 'Movies with a rating of 5',
                    showarrow: true,
                    arrowhead: 3,
                    ax: -30,
                    ay: -30
                },

                {
                    x: 2,
                    y: -0.4,
                    xref: 'x',
                    yref: 'y',
                    text: 'EmbeddingFM',
                    showarrow: false,
                    arrowhead: 3,
                    ax: -50,
                    ay: 50
                },
                {
                    x: 2,
                    y: 2.9,
                    xref: 'x',
                    yref: 'y',
                    text: 'DeepFM',
                    showarrow: false,
                    arrowhead: 3,
                    ax: -50,
                    ay: 50
                }
            ],
            xaxis: {
                range: [-0.6, 3.1],
                showticklabels: false,
                autotick: false,
                showgrid: false,
                zeroline: false
            },
            yaxis: {
                range: [-0.6, 3.1],
                showticklabels: false,
                autotick: false,
                showgrid: false,
                zeroline: false
            },
            plot_bgcolor: "rgba(0,0,0,0)",
            paper_bgcolor: "rgba(0,0,0,0)",
            showlegend: false,
            shapes: [
                {
                    opacity: 0.3,
                    xref: 'x',
                    yref: 'y',
                    fillcolor: 'rgba(0,0,0,0)',
                    x0: 0,
                    y0: 0,
                    x1: 2,
                    y1: 2,
                    type: 'circle',
                    line: {
                        color: 'green'
                    }
                }, {
                    opacity: 0.3,
                    xref: 'x',
                    yref: 'y',
                    fillcolor: "rgba(0,0,0,0)",
                    x0: 1,
                    y0: -0.5,
                    x1: 3,
                    y1: 1.5,
                    type: 'circle',
                    line: {
                        color: '#F6A720',
                    }
                },
                {
                    opacity: 0.3,
                    xref: 'x',
                    yref: 'y',
                    fillcolor: 'rgba(0,0,0,0)',
                    x0: 1,
                    y0: 1,
                    x1: 3,
                    y1: 3,
                    type: 'circle',
                    line: {
                        color: '#392D32'
                    }
                }
            ],
            margin: {
                l: 35,
                r: 35,
                b: 35,
                t: 35
            },
            height: 700,
            width: 700
        };

        var data = [trace1, trace2, trace3, trace4, trace5, trace6, trace7];

        function addLinesAndCirclesModelYves(trace) {
            for (var i = 0; i < trace.x.length; i++) {
                layout.shapes.push({
                    type: 'line',
                    x0: trace.x[i],
                    y0: trace.y[i],
                    x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                    y1: trace.y[i],
                    opacity: 0.7,
                    line: {
                        color: 'red',
                        width: 1.5
                    }
                },
                    {
                        opacity: 0.3,
                        xref: 'x',
                        yref: 'y',
                        fillcolor: '#F6A720',
                        x0: trace.x[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y0: trace.y[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y1: trace.y[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        type: 'circle',
                        line: {
                            color: 'black'
                        }
                    })
            }
        }

        function addLinesAndCirclesModelYvesAndIbra(trace) {
            for (var i = 0; i < trace.x.length; i++) {
                layout.shapes.push({
                    type: 'line',
                    x0: trace.x[i],
                    y0: trace.y[i],
                    x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                    y1: trace.y[i],
                    opacity: 0.7,
                    line: {
                        color: 'red',
                        width: 1.5
                    }
                },
                    {
                        type: 'line',
                        x0: trace.x[i],
                        y0: trace.y[i],
                        x1: trace.x[i],
                        y1: trace.y[i] + map_to_range(trace.errorIbra[i], in_min, in_max, out_min, out_max),
                        opacity: 0.7,
                        line: {
                            color: 'red',
                            width: 1.5
                        }
                    },
                    {
                        opacity: 0.3,
                        xref: 'x',
                        yref: 'y',
                        fillcolor: 'rgba(0,0,0,0)',
                        x0: trace.x[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y0: trace.y[i] - map_to_range(trace.errorIbra[i], in_min, in_max, out_min, out_max),
                        x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y1: trace.y[i] + map_to_range(trace.errorIbra[i], in_min, in_max, out_min, out_max),
                        type: 'circle',
                        line: {
                            color: 'black'
                        }
                    })
            }
        }


        function addLinesAndCirclesModelIbra(trace) {
            for (var i = 0; i < trace.x.length; i++) {
                layout.shapes.push({
                    type: 'line',
                    x0: trace.x[i],
                    y0: trace.y[i],
                    x1: trace.x[i],
                    y1: trace.y[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                    opacity: 0.7,
                    line: {
                        color: 'red',
                        width: 1.5
                    }
                },
                    {
                        opacity: 0.3,
                        xref: 'x',
                        yref: 'y',
                        fillcolor: '#392D32',
                        x0: trace.x[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y0: trace.y[i] - map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        x1: trace.x[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        y1: trace.y[i] + map_to_range(trace.error[i], in_min, in_max, out_min, out_max),
                        type: 'circle',
                        line: {
                            color: 'black'
                        }
                    })
            }
        }
        addLinesAndCirclesModelYvesAndIbra(trace1)
        addLinesAndCirclesModelYves(trace3)
        addLinesAndCirclesModelYves(trace2)
        addLinesAndCirclesModelIbra(trace4)
        addLinesAndCirclesModelYvesAndIbra(trace5)
        addLinesAndCirclesModelYvesAndIbra(trace6)
        addLinesAndCirclesModelIbra(trace7)


        Plotly.newPlot('myDiv', data, layout, { displayModeBar: false });

    </script>
</body>